# Genetic modulators of responses to microenvironmental stimulation {#chapter5}
Profiling the effects of the panel of stimuli revealed the heterogenous nature of responses to stimulation. The analysis revealed four  patient sample groups, with distinct responses to the stimuli, unique molecular profiles, and differential disease progression. Two pathways emerged as the most potent modulators of CLL viability, namely IL4 and TLR. These too induced heterogeneous responses across the cohort, in particular stimulation of TLR 7/8/9 increased viability in some samples, whilst it reduced viability in others. 

Next we asked to what extent this heterogeneity of response relates to the molecular profiles of the tumours. We sought to understand which underlying genetic features might modulate responses to external signals, and how these interactions may occur.  We combined the screening dataset with multi-omics profiles of the patient samples taken from the PACE repository [@JCIpaper; @R-BloodCancerMultiOmics2017] and performed a systematic survey of molecular determinants of stimulus response, using whole-exome sequencing, DNA-methylation, RNA-sequencing and copy number variant data. In addition, for a small subset of patients we also generated  ATAC sequencing and Mass Spectrometry data. 

Collectively, these data enabled us to probe genetic and epigenetic modulators of microenvironmental signalling, in a heterogeneous cohort that encompasses the clinical and molecular diversity of CLL. In the first part of this chapter, I apply a broad systematic approach to identify important genetic modulators, and in the second, I outline my follow-up investigations into the impact of trisomy 12 on stimulus response. 

```{r, echo = FALSE}

knitr::opts_chunk$set(
   echo = FALSE, 
   message = FALSE, 
   warning = FALSE,
   fig.align="center"
)

```

```{r setup05, echo = FALSE}
#libraries

library(clusterProfiler)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(ChIPseeker)
library(genomation)
library(DESeq2)
library(ggbeeswarm)
library(ggpubr)
library(ggplot2)
library(magrittr)
library(gtable)
library(glmnet)
library(patchwork)
library(scales)
library(gridExtra)
library(ggrepel)
library(broom)
library(plyr)
library(dplyr)
library(tidyverse)
library(msigdbr)
library(png)
library(cowplot)
library(Hmisc)
library(MultiAssayExperiment)
library(biomartr)
library(biomaRt)
library(patchwork)
library(biobroom)

```

```{r loadData05, eval = TRUE}

#data("df", "patMeta", "LDT", "survT", "dds_smp")
#df_complete <- df

#Data
#df: tibble containing all screening viability data
load("data/df.RData")
df_complete <- df

#patMeta: tibble containing all patient genetic data
load("data/patMeta.RData")


#diffTF_large: tibble containing diffTF weighted mean difference values for 636 TFs, for trisomy 12 versus non-trisomy 12 CLL ATACseq data
load( "data/diffTF_large.RData")


#diffTF_small: tibble containing diffTF weighted mean difference values for 636 TFs, for trisomy 12 versus non-trisomy 12 CLL ATACseq data
load( "data/diffTF_small.RData")

#ChIPseq data for SPIB and PU1 binding in OCILY3 cell line (downloaded from GEO)
#get info on dataset of interest
chipSeq <- getGEOInfo(genome="hg19", simplify=FALSE) %>% dplyr::filter(series_id=="GSE56857")
#Define gsm id for SPIB and PU1 ChIPseq dataset in OCILY3 cell line (DLBCL)
gsm_spib = "GSM1370276"
gsm_pu1 = "GSM1370275"                                                         
#download bed file if not already there                                          
downloadGSMbedFiles(gsm_spib, destDir="data/")
downloadGSMbedFiles(gsm_pu1, destDir="data/")

#read the data
#ChIPseq data downloaded from GEO Accession Number: GSE56857
peak.spib <-  genomation ::readBed("data/GSM1370276_OCILY3_SPIB_GEM_events.bed.gz", track.line = "auto")
peak.pu1 <-  genomation ::readBed( "data/GSM1370275_OCILY3_PU1_GEM_events.bed.gz", track.line = "auto")


#SPIB_KD_Cellcounts: a tibble containing Normalized Cell Counts for Cell Lines infected with shRNA against SPIB and PU1 from Tina Becirovic
load( "data/SPIB_KD_Cellcounts.RData")


#Load proteomics data from Sophie Herbst
load("data/multiomics_MAE.RData")


#Full RNA dataset: Deseq2 object
load("data/dds_smp_full.RData")

#Matching samples only RNA dataset: Deseq2 object
load("data/dds_smp.RData")

#cytReceptors: tibble containing meta data on cytokine receptors
load( "data/cytReceptors.RData")

#cyt_and_receptors: tibble containing meta data on cytokines and receptors
load( "data/cyt_and_receptors.RData")


```

```{r themes_functions05, echo = FALSE, eval = TRUE}

### ggplot themes
fontsize = 11

## theme for ggplots
t1 <- 
  theme(                              
  plot.background = element_blank(), 
  panel.grid.major = element_line(),
  panel.grid.major.x = element_line(linetype = "dotted", colour = "grey"),
  panel.grid.minor = element_blank(), 
  panel.border = element_blank(), 
  panel.background = element_blank(),
  axis.line = element_line(size=.4),
  axis.line.x = element_line(),
  axis.line.y = element_line(),
  axis.text.x  = element_text(angle=90, size=11, hjust = 1, vjust = 0.4),
  axis.text.y = element_text(size = 11),
  axis.ticks.length = unit(0.3,"cm"),
  axis.title.x = element_text(face="bold", size=13), 
  axis.title.y = element_text(face="bold", size=13),
  plot.title = element_text(face="bold", size=14, hjust = 0.5),
  strip.text = element_text(size = fontsize)
)

t2 <- t1+
  theme( axis.text.x  = element_text(angle=0, size=11, hjust = 0.5, vjust = 1))

## theme for legends
t.leg <-  theme(legend.title = element_text(face='bold', 
                                            hjust = 1, size=11),
                legend.key = element_blank(),
                legend.text = element_text(size=11),
                legend.background = element_rect(color = "black"))



### Set colour palettes

#For Categorical: 
colors <- c("#A1BE1F", #green
            "#F4C61F", #yellow
            "#734595", #purple
            "#D41645", #red
            "#3B6FB6", #blue
            "#B65417", #orange
            "#E2E868", #light green
            "#CBA3D8", #light purple
            "#E58F9E", #light purple
            "#8BB8E8", #light blue
            "#F49E17", #light orange
            "#303030", #black
            "#A8A99E", #grey
            "#007B53") #dark green



#For Divergent: 
Divergent <- c("#003DA5", "#2055B0", "#406EBC", "#6086C7", "#809ED2", "#9FB6DD", "#BFCFE9", "#DFE7F4", "white", "white", "white","#F4E0E7", "#E9C2CF", "#DEA3B6", "#D3849E", "#C76586", "#BC476E", "#B12855", "#A6093D")

#for negatives only: 
palblues <- c("#003DA5", "#2055B0", "#406EBC", "#6086C7", "#809ED2", "#9FB6DD", "#BFCFE9", "#DFE7F4")

#for positives only:
palreds <- c("#F4E0E7", "#E9C2CF", "#DEA3B6", "#D3849E", "#C76586", "#BC476E", "#B12855", "#A6093D")

#For mutations: 
Mutant <- c("#b5b5b5","#373A36")
Sex <- c("#707372","#D0D0CE")
IGHV <- c("#373A36","#D0D0CE")
Methylation_cluster <- c("#373A36","#A8A99E","#D0D0CE")

#For drugs: 
drugpal <- c("#734595", "#CBA3D8") #purples

#For cytokines: 
cytpal <- c("#F49E17", "#EFC06E") #yellows


#neutral
offwhite <- "#f8f8ff"
lightergrey <- "#D0D0CE"
darkergrey <- "#707372"


na_color="#f0f0f0"


###FUNCTIONS
#select lasso or ridge 
runGlm05 <- function(X, y, method = "lasso", repeats=30, folds = 3) {
  
  #set up objects
  modelList <- list()
  lambdaList <- c()
  varExplain <- c()
  
  #set up a matrix for values of coefficients, with a row for each feature, and a column for each repeat
  coefMat <- matrix(NA, ncol(X), repeats)
  
  #make row names = genetic features
  rownames(coefMat) <- colnames(X)
  #set alpha according to selected method
  if (method == "lasso"){
    alpha = 1
  } else if (method == "ridge") {
    alpha = 0
  }
  
  #Run cv.glmnet for chosen number of repeats 
  for (i in seq(repeats)) {
    
    #if there are more than two features, fit a glm
    if (ncol(X) > 2) {
      
      res <- cv.glmnet(X,y, type.measure = "mse", family="gaussian", 
                       nfolds = folds, alpha = alpha, standardize = FALSE)
      
      #add lambda min from this repeat to the list of lambdas
      lambdaList <- c(lambdaList, res$lambda.min)
      
      #put the res object (with lambdas) into the list of models
      modelList[[i]] <- res
      
      #extract the coefficients for each feature, for lambda.min
      coefModel <- coef(res, s = "lambda.min")[-1] #remove intercept row
      
      #put these coefficients into  column of coefMatrix corresponding to the repeat
      coefMat[,i] <- coefModel
      
      #calculate variance explained
      y.pred <- predict(res, s = "lambda.min", newx = X)
      varExp <- cor(as.vector(y),as.vector(y.pred))^2
      varExplain[i] <- ifelse(is.na(varExp), 0, varExp) 
      
     
      
    } else {
      #if there are only two features, fit a linear model
      fitlm<-lm(y~., data.frame(X))
      varExp <- summary(fitlm)$r.squared
      varExplain <- c(varExplain, varExp)
      
    }
  }
  #gather all lists
  list(modelList = modelList, lambdaList = lambdaList, varExplain = varExplain, coefMat = coefMat)
}


makelegends <- function (legendFor, colors) {
    x = NULL
    y = NULL
    colors = colors[names(colors) %in% legendFor]
    nleg = length(colors)
    
    #set up gtable
    wdths = c(0.4,2,2,2,1.5)
    hghts = c(2)
    
    gtl = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    n = 2
    
    #legend for Methylation Cluster
    if ("M" %in% names(colors)) {
        Mgg = ggplot(data = data.frame(x = 1, 
                                       y = factor(c("LP", "IP", "HP"), 
                                                  levels = c("LP", "IP", "HP"))), 
                     aes(x = x, y = y, fill = y)) + 
              geom_tile() + 
              scale_fill_manual(name = "Methylation cluster", 
                                values = setNames(colors[["M"]], 
                                                  nm = c("LP", "IP","HP"))) + 
              theme(legend.title = element_text(size = 12), 
                    legend.text = element_text(size = 12))
        
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Mgg), "guide-box"), 1, n)
        n = n + 1
    }
    
    #Legend for IGHV status
    if ("I" %in% names(colors)) {
        Igg = ggplot(data = data.frame(x = 1, y = factor(c("Unmutated", 
            "Mutated"), levels = c("Unmutated", "Mutated"))), 
            aes(x = x, y = y, fill = y)) + geom_tile() + scale_fill_manual(name = "IGHV", 
            values = setNames(colors[["I"]], nm = c("Unmutated", "Mutated"))) + 
            theme(legend.title = element_text(size = 12), 
                  legend.text = element_text(size = 12))
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Igg), 
            "guide-box"), 1, n)
        n = n + 1
    }
    
    #legend for gene mutations
    if ("G" %in% names(colors)) {
        Ggg = ggplot(data = data.frame(x = 1, y = factor(c("Wild Type", 
            "Mutated"), levels = c("Wild Type", "Mutated"))), 
            aes(x = x, y = y, fill = y)) + geom_tile() + scale_fill_manual(name = "Gene", 
            values = setNames(colors[["G"]], nm = c("Wild Type", "Mutated"))) + 
            theme(legend.title = element_text(size = 12), 
                  legend.text = element_text(size = 12))
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Ggg), 
            "guide-box"), 1, n)
        n = n + 1
    }
    
    return(list(plot = gtl, width = sum(wdths), height = sum(hghts)))
}

lassoPlot05 <- function(lassoOut, geneMatrix, viabMatrix, freqCut = 1, coefCut = 0.01) {
  
  plotList <- list()
  
  for (seaName in names(lassoOut)) { 
    ###FOR THE BAR PLOT
    #extract coefMat for each stimulus
    barValue <- rowMeans(lassoOut[[seaName]]$coefMat)
    #extract proportion of repeats for which each coefficient is significant
    freqValue <- rowMeans(abs(sign(lassoOut[[seaName]]$coefMat)))
    #filter out coefficients that don't meet freqCut and coefCut thresholds
    barValue <- barValue[abs(barValue) >= coefCut & freqValue >= freqCut] 
    #arrange the bar values in numerical order
    barValue <- barValue[order(barValue)]
    #if there are no sig coefficients, don't plot
    if(length(barValue) == 0) {
      plotList[[seaName]] <- NA
      next
    }
    ###FOR THE HEATMAP AND SCATTER PLOT
    #get feature matrix and response matrix to plot
    allData <- geneMatrix
    viabValue <- unlist(viabMatrix[seaName,])
    
    #get feature matrix for sig coefficients only
    tabValue <- allData[, names(barValue),drop=FALSE]
    ord <- order(viabValue)
    viabValue <- viabValue[ord]
    tabValue <- tabValue[ord, ,drop=FALSE]
    sampleIDs <- rownames(tabValue)
    tabValue <- as_tibble(tabValue)
    tabValue$Sample <- sampleIDs
    
    
    #annotate mutations by mutation, methylation or IGHV
    matValue <- gather(tabValue, key = "Var",value = "Value", -Sample)
    matValue$Type <- "mut"
    
    #for Methylation Cluster
    matValue$Type[grep("Methylation",matValue$Var)] <- "meth"
    
    #for IGHV status
    matValue$Type[grep("IGHV",matValue$Var)] <- "ighv"
    
    #change the scale of the value so that IGHV, Methylation and Mutation do not overlap
    matValue[matValue$Type == "mut",]$Value = matValue[matValue$Type == "mut",]$Value + 10
    matValue[matValue$Type == "meth",]$Value = matValue[matValue$Type == "meth",]$Value + 20
    matValue[matValue$Type == "ighv",]$Value = matValue[matValue$Type == "ighv",]$Value + 30
    
    #change continuous to categorical
    matValue$Value <- factor(matValue$Value,levels = sort(unique(matValue$Value)))
    
    #arrange order of heatmap
    matValue$Var <- factor(matValue$Var, levels = names(barValue))
    matValue$Sample <- factor(matValue$Sample, levels = names(viabValue))
    
    #change labels if mutation is a Doehner mutation 
    matValue$Var <- revalue(matValue$Var, c("del11q" = "del(11q)", "del13q" = "del(13q)", "del17p" = "del(17p)", "trisomy12" = "trisomy 12")) 
    
   
     #plot the heatmap 
      #title
    if(seaName=="TGF-b1"){
      thetitle <- "TGF-\u03B21"     
      } else {
        if(seaName=='IL-4'){ 
          thetitle <- "IL4"  
          } else {
            thetitle <- seaName
          }
        }
    
      p1 <- ggplot(matValue, aes(x=Sample, y=Var)) + 
            geom_tile(aes(fill=Value), color = "white") + #ghost white
            theme_bw()+
            scale_y_discrete(expand=c(0,0)) + 
            theme(axis.title.y = element_text( size=14),
                  axis.title.x = element_text( size=14),
                  axis.text.x=element_text(hjust=0, size=11),
                  axis.text.y=element_text(hjust=0.1, size=11),
                  axis.ticks=element_blank(),
                  panel.border=element_rect(colour="gainsboro"),  
                  plot.title=element_text(face="bold", size = 18, margin = margin(t = -5, b = 1)), 
                  panel.background=element_blank(),
                  panel.grid.major=element_blank(), 
                  panel.grid.minor=element_blank()) + 
            xlab("Mutation status for each patient") + 
            ylab("") + 
            scale_fill_manual(name="Mutated", 
                              values=c(`10`= offwhite,  #WT
                                       `11`="#373A36", #Mutant
                                       `20`= offwhite, #LP
                                       `20.5`= "#707372", #IP
                                       `21` = "#A8A99E", #HP
                                       `30` = offwhite, #IGHV-U
                                       `31` = "#707372"), #IGHV-M
                                       guide="none") + 
            ggtitle(thetitle)
        
         
    #Plot the bar plot on the left of the heatmap 
    barDF = data.frame(barValue, nm=factor(names(barValue),levels=names(barValue)))
    
    p2 <- ggplot(data=barDF, aes(x=nm, y=barValue)) + 
      geom_bar(stat="identity", 
               fill=ifelse(barValue<0,
                           palblues[6],palreds[8]), 
               colour="black", 
               size=0.3) + 
      scale_x_discrete(expand=c(0,0.5)) + 
      scale_y_continuous(expand=c(0,0)) + 
      coord_flip(ylim=c(-0.3,0.35)) + #changed from min(barValue) and max(barValue)
      theme(panel.grid.major=element_blank(), 
            panel.background=element_blank(), 
            axis.ticks.y = element_blank(),
            panel.grid.minor = element_blank(), 
            axis.text=element_text(size=11, angle = 45, hjust = 1, vjust = 1),
                axis.title = element_text(size=14), 
            panel.border=element_blank()) +
      ylab("Size of predictor") + 
      geom_vline(xintercept=c(0.5), 
                 color="black", 
                 size=0.6)
    
    #Plot the scatter plot under the heatmap
    scatterDF = data.frame(X=factor(names(viabValue), 
                                    levels=names(viabValue)), 
                           Y=unlist(viabValue))
    
    p3 <- 
      ggplot(scatterDF, aes(x=X, y=Y)) + 
      geom_point(shape=21, 
                     fill="dimgrey", 
                     colour="#707372", #dark grey
                     size=1.2) + 
      theme_bw() +
      theme(panel.grid.minor=element_blank(), 
                panel.grid.major.x=element_blank(), 
                #axis.title.x=element_blank(), 
                axis.ticks.x=element_blank(), 
                axis.text.y=element_text(size=11), 
                axis.title.x=element_text(size=14), 
                panel.border=element_rect(colour="dimgrey", size=0.1),
                panel.background=element_rect(fill="white")) +
      xlab("Log(Viability) for each sample")
    
    
    #Assemble all the plots togehter
    # construct the gtable
    wdths = c(0.2, 1.5, 0.2, 1.3*ncol(matValue), 1.5, 0.2)
    hghts = c(0.2, 0.2, 0.0020*nrow(matValue), 0.3, 1, 0.2)
    gt = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    
    ## make grobs
    gg1 = ggplotGrob(p1)
    gg2 = ggplotGrob(p2)
    gg3 = ggplotGrob(p3)
    ## fill in the gtable
   
    #HEATMAP
    #5:1 = "PREDICTORS"
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) # add heatmap
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) #add legend
    gt = gtable_add_grob(gt, gtable_filter(gg1, "title"), 1, 4) #add title to plot
    gt = gtable_add_grob(gt, gtable_filter(gg1, "axis-l"), 3, 5) # variable names
    gt = gtable_add_grob(gt, gtable_filter(gg1, "xlab-b"), 2, 4) # axis title
    
    #BARPLOT
    gt = gtable_add_grob(gt, gtable_filter(gg2, "panel"), 3, 2) # add barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-b"), 4, 2) # y axis for barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "xlab-b"), 2, 2) # y lab for barplot
    
    #SCATTER PLOT
    gt = gtable_add_grob(gt, gtable_filter(gg3, "panel"), 5, 4) # add scatterplot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "xlab-b"), 6, 4) # x label for scatter plot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "axis-l"), 5, 3) #  axis for scatter plot
    
   
    
    #plot
    #grid.draw(gt)
    plotList[[seaName]] <- gt
  }
  return(plotList)
  
  
  
}



########### Scaling and Centering of Viability Matrix ################

# medianCenter_MadScale: 
#function to  scale with MAD, center to merdian
medianCenter_MadScale05 <- function(x) {
  s <- median(x)
  #s=0
  (x - s) / mad(x, center = s)
}

# scaleCytResp function:  to apply medianCenter_MadScale row wise to viability matrix
scaleCytResp05  <- function(x) t(apply(x, 1, medianCenter_MadScale05)) 

#ROC cruve

#function to plot ROC curves
plotROC05 <- function(glmModel, X, y, lambda = "lambda.1se") {
  lambdaChose <- glmModel[[lambda]]
  glmPred <- prediction(predict(glmModel, type = "response", newx = X, s=lambdaChose), y)
  glmPerform <- performance(glmPred,"tpr","fpr")
  aucVal <- performance(glmPred, measure = "auc")@y.values[[1]]
  xname <- glmPerform@x.name
  yname <- glmPerform@y.name
  plotTab <- tibble(x= glmPerform@x.values[[1]],
                    y = glmPerform@y.values[[1]])
  p <- ggplot(plotTab, aes(x=x, y =y )) + geom_line(color = "red") +
    xlab(xname) + ylab(yname) + theme(panel.grid = element_blank())
  
  if (!is.null(aucVal)) {
    p <- p + annotate("text", x= 0.75, y = 0.25, label = sprintf("AUC: %1.2f", aucVal))
  }
  list(plot=p, auc = aucVal)
}

#indicate how to split test set and training set
testPartition05 <- function(y, ratio) {
  #balanced sampling of test set
  ord <- seq_along(y)
  testIdx <- lapply(unique(y),function(n) {
    subY <- ord[y == n]
    sample(subY, size = as.integer(length(subY)  * ratio)) 
  }) %>% do.call(c,.) %>% sort()
  return(testIdx)
}

#Function for multi-variant binomial regression
runGlm.bin <- function(X, y, method = "lasso", repeats=20, folds = 3, testRatio = NULL, lambda = "lambda.1se") {
  modelList <- list()
  lambdaList <- c()
  aucCV <- c()
  aucTest <- c()
  rocTest <- list()
  coefMat  <- matrix(NA, ncol(X), repeats)
  rownames(coefMat) <- colnames(X)
  
  if (method == "lasso"){
    alpha = 1
  } else if (method == "ridge") {
    alpha = 0
  }
  
  for (i in seq(repeats)) {
    if (!is.null(testRatio)) {
      testIdx <- testPartition(y, testRatio)
      X.test <- X[testIdx,]
      X.train <- X[-testIdx,]
      y.test <- y[testIdx]
      y.train <- y[-testIdx]
    } else {
      X.train <- X
      y.train <- y
    }
    
    #need to add a set seed for this function, but ensure that it changes with each loop otherwise all 10 repeats are the same 
    vecFold <- mltools::folds(y.train, nfolds = folds, stratified = TRUE, seed = i)
    
    #train model
    res <- cv.glmnet(X.train,y.train, type.measure = "auc",
                      foldid = vecFold, alpha = alpha, standardize = FALSE,
                     intercept = TRUE, family = "binomial")
    lambdaList <- c(lambdaList, res[[lambda]])
    #If you arent splitting the data into a training and testing dataset. you can use the AUC for the CV
    aucCV <- c(aucCV, res$cvm[res$lambda == res[[lambda]]])
    modelList[[i]] <- res
    coefMat[,i] <- coef(res, s = lambda)[-1]
    
    #test model if testRatio is speficied- can use this AUC to identify the best model 
    if(!is.null(testRatio)) {
      rocRes <- plotROC(res, X.test, y.test, lambda)
      aucTest <- c(aucTest, rocRes$auc)
      rocTest[[i]] <- rocRes$plot
    }
  }
  list(modelList = modelList, lambdaList = lambdaList, aucCV = aucCV, coefMat = coefMat,
       aucTest = aucTest, rocTest = rocTest)
}

#function to visualise predictors of Trisomy 12 status
lassoPlot_bin <- function(lassoOut, xIn, yIn, freqCut = 1, coefCut = 0.01, symbolMap = NULL, modelIndex = NULL, textWidth =0.8, rowHeight = 0.0005) {
  
    #for the barplot on the left of the heatmap
    if (is.null(modelIndex)) {
      #average all models
      barValue <- rowMeans(lassoOut$coefMat)
      freqValue <- rowMeans(lassoOut$coefMat !=0)
      barValue <- barValue[abs(barValue) > coefCut & freqValue >= freqCut] # a certain threshold
      barValue <- barValue[order(barValue)]
      if(length(barValue) == 0) {
        return(NA)
      }
    } else {
      #using a specificed model
      barValue <- lassoOut$coefMat[,modelIndex]
      barValue <- barValue[abs(barValue) > coefCut] # a certain threshold
      barValue <- barValue[order(barValue)]
      if(length(barValue) == 0) {
        return(NA)
      }
    }
    
    #for the heatmap and scatter plot below the heatmap
    mapData <- xIn
    scatterData <- yIn
    
    ord <- order(scatterData)
    scatterData <- scatterData[ord]
    mapData <- mapData[ord, names(barValue) ,drop=FALSE]
    idOrd <- rownames(mapData) #to record the order of the rows
    mapData <- mapData %>% as_tibble() %>% mutate(row = idOrd) %>%
      gather(key = "Var", value = "Value", -row) %>%
      mutate(row = factor(row, levels = idOrd),
             Var = factor(Var, levels = names(barValue)))
    #add tri12 status
    tri12meta <- dplyr::select(patMeta, PatientID, trisomy12) 
    tri12meta$PatientID <- as.factor(tri12meta$PatientID)
    colnames(mapData) <- c("PatientID", "Var", "Value")
    mapData_tri12 <- left_join(mapData, tri12meta, by =  "PatientID")
    
    #update labeling 
    mapData_tri12$Var <- revalue(mapData_tri12$Var, c("Resiquimod" = "Resiquimod", "TGF-b1" = "TGF-\u03B21", "sCD40L+IL-4" = "sCD40L + IL4")) 
    
    #plot the heatmap
    p1 <- ggplot(mapData_tri12, aes(x=PatientID, y=Var)) + geom_tile(aes(fill=Value),color = "gray") + 
      theme_bw()  + 
      theme(axis.text.x=element_blank(), axis.ticks=element_blank(), 
            panel.border=element_rect(colour="gainsboro"),  
            plot.title=element_text(size=18), 
            panel.background=element_blank(), 
            panel.grid.major=element_blank(), 
            panel.grid.minor=element_blank()) + 
      xlab("Samples") + ylab("Log(Viability)") + 
      ggtitle("")+
      scale_fill_gradient2(low = palblues[1],high = palreds[8], mid = "white",guide="none")+ 
      facet_grid(~trisomy12, space = "free", scales = "free") + theme(strip.background =element_rect(fill="white"))
    
    #Plot the bar plot on the left of the heatmap
    if (is.null(symbolMap)) {
      barDF = data.frame(barValue=barValue, 
                         nm=factor(names(barValue),levels=names(barValue)))
    } else {
      #a id to symbol dataframe is provided
      barDF = data.frame(barValue = barValue, 
                         nm = symbolMap[names(barValue),1])
      barDF$nm <- factor(barDF$nm, levels = unique(barDF$nm))
    }
    
    p2 <- ggplot(data=barDF, aes(x=nm, y=barValue)) + 
      geom_bar(stat="identity", fill=darkergrey, colour="black", position = "identity", width=.66, size=0.2) + 
      theme_bw() + geom_hline(yintercept=0, size=0.3) + scale_x_discrete(expand=c(0,0.5)) + 
      scale_y_continuous(expand=c(0,0)) + 
      coord_flip(ylim=c(min(barValue),max(barValue))) + 
      theme(panel.grid.major=element_blank(), 
            panel.background=element_blank(), axis.ticks.y = element_blank(),
            panel.grid.minor = element_blank(), axis.text.y=element_text(size=8, hjust=0),
            axis.text.x = element_text(size=10),
            panel.border=element_blank()) +
      xlab("") + 
      ylab("Size of predictor") + 
      geom_vline(xintercept=c(0.5), color="black", size=0.6)
    

    #Scale bar for continuous variable

    Vgg = ggplot(mapData, aes(x=PatientID, y=Var, col = Value)) + 
      geom_point() + 
      scale_color_gradient2(low = palblues[1],high = palreds[8], mid = "white", name = "z-score") + 
      theme(legend.title=element_text(size=10), legend.text=element_text(size=10))
    
    #Assemble all the plots together

    # construct the gtable
    
    wdths = c(1.5, 0.2, 1.3*ncol(mapData), textWidth,0.8)
    hghts = c(0.2, rowHeight*nrow(mapData), 0.2, 0.5)
    gt = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    
    ## make grobs
    gg1 = ggplotGrob(p1)
    gg2 = ggplotGrob(p2)
    gg4 = ggplotGrob(Vgg)
    
    ## fill in the gtable
    gt = gtable_add_grob(gt, gtable_filter(gg2, "panel"), 2, 1) # add barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "xlab-b"), 1, 1) # add  y axis label to barplot 
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 2, 3) # add heatmap
    gt = gtable_add_grob(gt, gtable_filter(gg1, "strip-t"), 1, 3) # add facetstip to plot
   
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-b"), 3, 1) # y axis for barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-l"), 2, 4) # variable names
    gt = gtable_add_grob(gt, gtable_filter(gg4, "guide-box"), 2, 5) # scale bar for continous variables

    
    #plot
    #grid.draw(gt)
    gt
}

```


```{r processData05, echo = FALSE}
#REMOVE
#Subset data to Cytokine only treatments, no drugs 
#Remake dataframe, then can load with this premade in future

df <- dplyr::filter(df, Drug == "DMSO", Cytokine != "No Cytokine") %>% 
  dplyr::mutate(Cytokine = as.character(Cytokine)) %>%
  dplyr::mutate(Cytlabel = ifelse(Cytokine == "IL-2", "IL2",
                            ifelse(Cytokine == "IL-4", "IL4",
                                   ifelse(Cytokine == "IL-6", "IL6", 
                                          ifelse(Cytokine == "IL-10", "IL10",
                                                 ifelse(Cytokine == "IL-10", "IL10",
                                                        ifelse(Cytokine == "IL-21", "IL21",
                                                               ifelse(Cytokine == "sCD40L+IL-4","sCD40L + IL4",
                                                                      ifelse(Cytokine == "IL-15", "IL15",
                                                                             ifelse(Cytokine == "Interferon gamma","Interferon \u03B3",
                                                                                    ifelse(Cytokine == "SDF-1a","SDF-1\u03B1",
                                                                                           ifelse(Cytokine == "IL-1b","IL-1\u03B2",
                                                                                                  ifelse(Cytokine == "TGF-b1","TGF\u03B2", Cytokine))))))))))))) %>%
  
  dplyr::mutate(Cytokine = factor(Cytokine))


df_complete <- df_complete %>%
  dplyr::mutate(Cytokine = as.character(Cytokine)) %>%
  dplyr::mutate(Cytlabel = ifelse(Cytokine == "IL-2", "IL2",
                            ifelse(Cytokine == "IL-4", "IL4",
                                   ifelse(Cytokine == "IL-6", "IL6", 
                                          ifelse(Cytokine == "IL-10", "IL10",
                                                 ifelse(Cytokine == "IL-10", "IL10",
                                                        ifelse(Cytokine == "IL-21", "IL21",
                                                               ifelse(Cytokine == "sCD40L+IL-4","sCD40L + IL4",
                                                                      ifelse(Cytokine == "IL-15", "IL15",
                                                                             ifelse(Cytokine == "Interferon gamma","Interferon \u03B3",
                                                                                    ifelse(Cytokine == "SDF-1a","SDF-1\u03B1",
                                                                                           ifelse(Cytokine == "IL-1b","IL-1\u03B2",
                                                                                                  ifelse(Cytokine == "TGF-b1","TGF\u03B2", Cytokine))))))))))))) %>%
  
  dplyr::mutate(Cytokine = factor(Cytokine))

#patMeta
patMeta$treatment <- as.factor(patMeta$treatment)
df_patmeta <- left_join(df, patMeta, by ="PatientID")

#Lists of Cytokines
thecytokines <- unique(df$Cytokine) %>% setdiff("No Cytokine")


#Cytokine labels 
#generate table of Cytokines and assosciated labels 
Cytokine_labels <- df %>% filter(PatientID == "Pat_001", Drug == "DMSO") %>% dplyr::select( Cytokine, Cytlabel)
colnames(Cytokine_labels) <- c("name", "Cytlabel")

```

## Systematic analysis of the effect of genetic features on responses to stimuli
### Univariate analysis identifies IGHV status and trisomy 12 as key modulators of microenvironmental response {#univariate-gene-stimulus-assosciations}
To begin, I ran a univariate analysis to compare viability values post-stimulation for patient samples with and without each genetic feature. In total 63 genetic features were surveyed, including IGHV status, somatic gene mutations and structural variants, where there were at least three patient samples in each group (Figure \@ref(fig:stimuliGeneAssosciations)). 

(ref:stimuliGeneAssosciations) Plot showing BH-adjusted p values from Student's t-tests (two-sided, with equal variance), for all tested gene-stimulus associations. Tests performed for IGHV status and somatic mutations and copy number aberrations with â‰¥3 patient samples in each group (n = 63 or is it 54??). Each circle represents a gene-stimulus association. Associations that meet 10% FDR cut off are indicated in colour, where the colour denotes the genetic feature. _Figure from Bruch & Giles et al. 2021._ See Methods section \@ref(univariate-gene-stimulus-associations-method).

```{r stimuliGeneAssosciations, fig.cap='(ref:stimuliGeneAssosciations)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

##################### List of mutations with >2 postive cases #############################
selected_mutations <- 
  patMeta %>% 
  mutate(Ras_Raf = as.factor(ifelse(BRAF == 1 | KRAS == 1| NRAS == 1, 1, 0))) %>% 
  dplyr::select(-BRAF, -KRAS, -NRAS) %>% 
  dplyr::select( -gender, 
                 -diagnosis, 
                 ) %>%
  pivot_longer(-PatientID, 
               names_to = "Genetic_Alteration", 
               values_to = "alteration_value") %>% 
  dplyr::filter(alteration_value %in% c(1, "U")) %>% 
  dplyr::group_by(Genetic_Alteration) %>% 
  dplyr::count() %>% 
  dplyr::filter(n>2) %>% 
  dplyr::select(Genetic_Alteration) %>% 
  unlist()

##################### t tests and p-value adjustment ###############################  
p_values <-
  ## Select columns from screening data 
  dplyr::select(df, PatientID, Log, Cytokine) %>% 
  
  ## Join Screening data with metadata
  left_join(patMeta, by = "PatientID") %>%
  
  ## Add Ras/Raf column, remove single columns
  mutate(Ras_Raf=as.factor(ifelse(BRAF == 1 | KRAS == 1 | NRAS == 1, 1, 0))) %>% 
  dplyr::select(-BRAF, -KRAS, -NRAS) %>% 
## remove unused columns from metadata
  dplyr::select( -gender, 
                 -diagnosis, 
                 -treatment) %>% 
  
  ## transform data to long format
  pivot_longer(cols=c(-PatientID, -Log, -Cytokine), 
               names_to = "Genetic_alt", 
               values_to = "alt_value") %>% 
  
  ## filter to selected mutations (see above)
  dplyr::filter(Genetic_alt %in% selected_mutations) %>% 
  
  
  ## group by Cytokine and Genetic alteration  
  dplyr::group_by(Cytokine, Genetic_alt) %>% 
  
  ## Perform t.test on every combination of Cytokine and genetic alteration
  do(tidy(t.test(Log ~ alt_value, data = ., var.equal = T))) %>% 
  
  ## ungroup before adjusting p-value
  ungroup() %>% 
  
  ## adjust p-values to multiple testing using BH method 
  mutate(adj.p.value=p.adjust(p.value, method = "BH"))
  
################################## Order of cytokines by descending significance ############################
Cytokine_order <-
  p_values %>% 
  dplyr::group_by(Cytokine) %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::filter(row_number() == 1) %>% 
  ungroup() %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::select(Cytokine) %>% 
  unlist()

Genetic_alt_order <-
  p_values %>% 
  dplyr::group_by(Genetic_alt) %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::filter(row_number() == 1) %>% 
  ungroup() %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::select(Genetic_alt) %>% 
  unlist()

############################# Define FDR cutoff #################################
fdr = 0.1
  
############################################ Plot ########################################
p_values %<>% 
  mutate(Cytokine=factor(Cytokine, levels = Cytokine_order)) %>% 
  mutate(Genetic_alt=factor(Genetic_alt, levels = Genetic_alt_order))
  
  ggplot(dplyr::filter(p_values, adj.p.value>fdr), 
         aes(x = Cytokine, y = -log10(adj.p.value))) +
  geom_point(color = "lightgrey", size = 3) +
  geom_beeswarm(data = dplyr::filter(p_values, adj.p.value <= fdr), 
                aes( color=Genetic_alt), size = 3, cex = 1.7) +
  ##FDR line  
  geom_hline(yintercept = -log10(fdr),linetype = "dashed", size=0.3)+
  
  ##Main Theme
  t1 +
  
  theme(axis.text.x = element_text(angle = 45,
                                   hjust = 1, 
                                   vjust = 1),
        axis.title.x=element_blank()) +
  ##Legend Theme
  theme(legend.position=c(0.65,0.65), 
        legend.title = element_text(face='bold', hjust = 0, size=13), 
        legend.key = element_blank(),  
        legend.text = element_text(size=11)) +
  guides(colour = guide_legend(nrow=7, title = "Mutations"), 
         shape = guide_legend(ncol = 1)) +
  scale_color_manual(name = "Mutations", values = colors, labels=c("IGHV.status"="IGHV status", 
                                                                   "del9p"="del(9p)", 
                                                                   "trisomy12"="trisomy 12", 
                                                                   "gain17q"="gain(17q)", 
                                                                   "gain2p"="gain(2p)",
                                                                   "gain19p"="gain(19p)",
                                                                   "gain19q"="gain(19q)",
                                                                   "del7q"="del(7q)",
                                                                   "del9q"="del(9q)", 
                                                                   "del4p"= "del(4p)", 
                                                                   "SPEN"="SPEN", 
                                                                   "del11q"="del(11q)", 
                                                                   "del1q" = "del(1q)")) +
  scale_y_continuous(expression("BH-adjusted  "* italic(p)*"-value"), 
                     breaks=seq(0, 10, 5),
                     labels=math_format(expr=10^.x)(-seq(0,10,5))) +
  
  scale_x_discrete(labels = c("TGF-b1"="TGF-\u03B21", "sCD40L+IL-4"="sCD40L + IL4", "IL-1b"="IL1\u03B2", "IL-4"="IL4", "IL-6"="IL6","IL-15"="IL15","IL-10"="IL10", "IL-21"="IL21","IL-2"="IL2", "Interferon gamma"= "Interferon \u03B3", "SDF-1a"="SDF-1\u03B1"))



```

This analysis revealed the extent to which genetic features modulate microenvironmental response: for ten out of 17 stimuli, at least one genetic feature determined  response and for six out of 17 stimuli, two or more genetic features significantly altered the response (Student's  t-tests,  FDR  =  10%, Bruch & Giles et al. 2021). The most common features were IGHV status and trisomy 12. Del(11q) also affected response to several stimuli. Notably,  del(13q) and del(17p), which like trisomy 12 and del(11q) are the most common aberrations in CLL and act as prognostic markers [@Dohner2000], had no impact on the responses to the panel of stimuli. 

### Multivariate analysis of gene - stimulus assosciations confirms IGHV status and trisomy 12 as key modulators of stimulus response {#multivariate-gene-stimulus-assosciations}
It was possible that there may be interplay between genetic factors in determining responses to external signals. To address this, I applied multivariate modelling to integrate the influence of genetic features, IGHV status and DNA methylation on the size of response (Bruch & Giles et al. 2021). I used a Gaussian linear model with L1-penalty (i.e., lasso regression),  to derive a predictor for each stimulus, comprised of these covariates. For background on this approach, see section \@ref(intro-multivariate-modelling).

As input to the model, the response matrix was composed of the log transformed viability values for each stimulus. To generate the feature matrix (137 samples versus 41 features), I excluded genetic features for which >20\% of the values were missing, and  patient samples with incomplete annotation. As predictors, I included genetic mutations and CNVs (p= 39), IGHV status (coded as 0-1) and Methylation Cluster (coded as 0, 0.5, 1). I ran lasso regression, as implemented in the `R` package `glmnet`[@R-glmnet], using three-fold cross-validation with misclassification error as loss. The resulting predictors are the mean of those coefficients that were selected in at least 75% of 30 bootstrapped repeats. 

Using the output of the regression, I generated predictor profiles for each stimulus. For 5 / 17 stimuli, there was at least one genetic predictor that met the cut-offs (a selection are shown in figure \@ref(fig:stimuliGeneAssosciationsMulti)).

(ref:stimuliGeneAssosciationsMulti) Predictor profiles for IL4 and CpG ODN depicting gene - stimulus associations. Bar plots (left) show size and sign of assigned coefficients from Gaussian linear modelling. A positive coefficient indicates that stimulated increase in viability is larger when feature is present. Scatter plots (bottom) and corresponding heatmaps above show how presence of selected genetic feature relates to sample viabilities. Scatter plots show ranked log(viability) values for each sample and heatmaps show mutation status for each predictor, for corresponding sample in scatter plot. See method \@ref(multivariate-gene-stimulus-assosciations-method). _Figure adapted from Bruch & Giles et al. 2021_.

```{r stimuliGeneAssosciationsMulti, fig.cap='(ref:stimuliGeneAssosciationsMulti)', message = FALSE,  echo = FALSE, fig.height=8, fig.width=8.5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

#Generate feature Matrix
#select features from patient meta file
geneMatrix <- 
  dplyr::select(patMeta,
                -c(gender:treatment)) %>%
  
  #adjust IGHV.status levels  U and M to numeric 1 and 0 
  mutate(IGHV = ifelse(is.na(IGHV.status), NA,
                       ifelse(IGHV.status == "M", 1, 0)), 
         #adjust Methylation_Cluster levels  LP, IP, HP to 0, 0.5, 1
         Methylation = ifelse(is.na(Methylation_Cluster), NA,
                              ifelse(Methylation_Cluster == "LP", 0,
                                     ifelse(Methylation_Cluster == "IP", 0.5, 1))),
         #remove old columns
         IGHV.status=NULL, Methylation_Cluster=NULL ) %>%

  
  #convert factors to numeric
  mutate_if(is.factor, as.character) %>%
  mutate_at(vars(-PatientID), as.numeric) %>%
  
  #convert to matrix format, with patient IDs as rownames
  data.frame() %>% 
  column_to_rownames("PatientID") %>% 
  as.matrix()
#Tidy matrix for use in glmnet function
#Remove genes with higher than 20% missing values
geneMatrix <- geneMatrix[,colSums(is.na(geneMatrix))/nrow(geneMatrix) <= 0.2]
#Filter for patients with complete data
geneMatrix.complete <- geneMatrix[complete.cases(geneMatrix),]
#Combine KRAS, NRAS and BRAF mutations into a single column
#set up empty matrix
Ras_Raf <- matrix(NA, 
                  nrow = nrow(geneMatrix.complete), 
                  ncol = 1)
colnames(Ras_Raf) <- "RAS/RAF"
#add RAS/RAF column to matrix
geneMatrix.complete <- cbind(geneMatrix.complete, Ras_Raf)
#Annotate RAS_RAF where where any of KRAS, NRAS or BRAF are mutated
geneMatrix.complete[,"RAS/RAF"] <- ifelse(geneMatrix.complete[,"KRAS"]==1,1,
		                                        ifelse(geneMatrix.complete[,"BRAF"]==1,1,
	                	                          ifelse(geneMatrix.complete[,"NRAS"]==1, 1, 0)))
#remove KRAS, NRAS and BRAF columns
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "KRAS"]
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "BRAF"]
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "NRAS"]


# Set up viability response matrix
viabMatrix <- 
  #select patients with complete meta data 
  dplyr::filter(df,
                PatientID %in% row.names(geneMatrix.complete)) %>%
  #select cytokine, patient and log(viability values only)
  dplyr::select(Cytokine, 
                Log, 
                PatientID) %>% 
  #reshape data
  spread(key = PatientID, value = Log) %>% 
  data.frame() %>% 
  #make Cytokine the row names
  remove_rownames() %>%
  column_to_rownames("Cytokine")
#make sample order same as in geneMatrix
viabMatrix <- viabMatrix[,rownames(geneMatrix.complete)]


#Run lasso regression
#set object to hold model outputs
dataResult <- list()
#fit model for each stimulus
for (i in rownames(viabMatrix)){  
  
    #prepare input and response matrices
    y <- unlist(viabMatrix[i,]) # viability for each patient with given condition
    X <- geneMatrix.complete #genetic features for each patient
    #fit the model
    cvglmfit <- runGlm05(X, y, method="lasso", repeats=30, folds=3)
    
    #collect the results for each stimulus in one object
    dataResult[[i]] <- cvglmfit
}


#Get predictor profiles for stimuli of interest

heatMaps_cyt <- lassoPlot05(dataResult[c("IL-4","CpG ODN")] , 
                          geneMatrix.complete, #use gene matrix for heatmap 
                          viabMatrix, #use viab matrix for scatter plot
                          freqCut = 0.75, #coefficients should be selected in <75% of bootstrapped model files
                          coefCut = 0.00) #no minimum value for coefficients 


#Assemble legend for heatmaps
#G# = gene mutations, I = IGHV, M = Methylation Cluster
legendFor = c("G", "I", "M")

#assign colours for I, G and M
coldef<-list()
coldef["I"] <- list(c(offwhite,"#707372")) #U-CLL and M-CLL
coldef["M"] <- list(c(offwhite, "#707372", "#A8A99E")) #IP, HP, LP
coldef["G"] <- list(c(offwhite, "#373A36")) #WT and Mutated
legends = makelegends(legendFor=c("G","I","M"),coldef)

#assemble
Fig3B_1 <- invisible(wrap_elements(arrangeGrob( grobs = heatMaps_cyt[1], ncol =1)))
Fig3B_2 <- invisible(wrap_elements(arrangeGrob( grobs = heatMaps_cyt[2], ncol =1)))
Fig3B_leg <- legends[["plot"]] %>% wrap_elements()



blankplot <- 
  ggplot() +
  geom_blank() +
  theme(panel.background = element_blank())

wrap_elements(Fig3B_1 + Fig3B_2 +
                wrap_elements(blankplot + Fig3B_leg + 
                                plot_layout(ncol=2, widths  = c(0.15,0.9))) +
                plot_layout(ncol=1, heights = c(1.7,1.7,0.5)))



```

The multivariate analysis demonstrated that responses to IL4 and sCD40L + IL4, TLR and TGF$\beta$ were all affected by multiple genetic features (Bruch & Giles et al. 2021). For example, higher viability in response to IL4 stimulation was associated with trisomy 12 and unmutated IGHV. In contrast, IL4 generated little or no increase in viability in samples with a mutation in KRAS, NRAS or BRAF. These tumours benefited less from the anti-apoptotic effects of IL4, indicating that the ability of IL4 to increase viability could be dependent on signalling via Ras-Raf-MEK-ERK, which is already active in mutant samples. 

Discussion that Inhibition of ERK (p38) also increased IL4 protective effect 

```{r ral_il4, fig.cap='(ref:ral_il4)', message = FALSE,  echo = FALSE, fig.height=6, fig.width = 10, fig.align="center", out.width = '60%', dev = 'cairo_pdf', eval = FALSE}

# Plot predictor profile for Ibrutinib + IL4

left_join(df_complete, patMeta, by = "PatientID") %>% 
  dplyr::filter(DCK%in% c("DMSO:IL-4", "Ralimetinib:IL-4")) %>%
         
  ggplot(aes(x=DCK,y=Log))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("Treatment") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

```
### Response to TLR stimulation is dependent on IGHV status, trisomy 12 and mutations in DNA Damage Response genes
The multivariate analysis highlighted that TLR stimulation by CpG ODN and Resiquimod both showed the largest number of predictors, reflecting the multiple layers of biology involved here. These included del(11q) and *ATM* , del(17p) and *TP53*, IGHV status, trisomy 12 and *SF3B1* (Bruch & Giles et al. 2021). Amongst the screening cohort, TLR stimulation increased viability in certain samples and decreased in others. The clustering groups identified in  section \@ref(clustering) also showed highly divergent responses to TLR, and this related to disease progression, thus warranting a more detailed look at the underlying features modulating TLR response (Figure \@ref(fig:TLRGenes)). 

(ref:TLRGenes) Control-normalised log transformed viability values after treatment with Resiquimod (TLR 7/8), stratified by named genetic features. 

```{r TLRGenes, fig.cap='(ref:TLRGenes)', message = FALSE,  echo = FALSE, fig.height = 6, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


ATM <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(ATM)) %>%
         
  ggplot(aes(x=ATM,y=Log,color=(ATM)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("ATM") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

del11q <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(del11q)) %>%
         
  ggplot(aes(x=del11q,y=Log,color=(del11q)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("del(11q)") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

SF3B1 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(SF3B1)) %>%
         
  ggplot(aes(x=SF3B1,y=Log,color=(SF3B1)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("SF3B1") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

trisomy12 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(trisomy12)) %>%
         
  ggplot(aes(x=trisomy12,y=Log,color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("trisomy 12") +
  ylab("Log(Viability)") +
  ggtitle("Resiquimod") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

del17p <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(del17p)) %>%
         
  ggplot(aes(x = del17p,y = Log,color = (del17p)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("del(17p)") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

TP53 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(TP53)) %>%
         
  ggplot(aes(x=TP53,y=Log,color=(TP53)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("TP53") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2



(del11q + trisomy12 + del17p)/
(ATM + SF3B1 + TP53)  

```

IGHV status (along with Methylation Cluster, which is related to IGHV) and trisomy 12 had the strongest effect on TLR response. @Chatzouli2014 have previously shown that TLR responses is dependent on IGHV status (see also, section \@ref(intro-ME-pathways). We noted trisomy 12 as an additional, novel determinant of TLR response (Bruch & Giles et al. 2021). In samples that do not have trisomy 12, TLR stimulation increases the viability of IGHV-U samples, whilst it decreases viability in IGHV-M samples, as expected. In contrast, in samples with trisomy 12, TLR stimulation increases viability regardless of IGHV status (Studentâ€™s t-test, p<0.001 and p=0.018, Figure \@ref(fig:TLRIHGVtri12)).

@Chatzouli2014's observations point to the existence of specific types of BCR/TLR collaboration  in CLL, leading to activation of pro-survival pathways, or apoptosis depending on the IGHV status of the tumour. Our results suggest that synergy between BCR and TLR may also be dependent on trisomy 12 status. 

(ref:TLRIHGVtri12) Beeswarm-boxplot showing control-normalised log transformed viability values, after treatment with Resiquimod, stratified by trisomy 12 and IGHV status. p-values from Studentâ€™s t-tests. _Figure from (Bruch & Giles et al. 2021)_

```{r TLRIHGVtri12, fig.cap='(ref:TLRIHGVtri12)', message = FALSE,  echo = FALSE, fig.height = 4, fig.width = 6,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

#filter for Resiquimod-only treatment, only show patients who are annotated for IGHV and Trisomy12
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod",
                !is.na(trisomy12),
                !is.na(IGHV.status)) %>%
         
  ggplot(aes(x=interaction(IGHV.status, trisomy12),
                    y=Log,
                    color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  scale_x_discrete(labels=c("M.0"="IGHV-M\n WT",
                            "U.0"="IGHV-U\n WT",
                            "M.1"="IGHV-M\n trisomy 12",
                            "U.1"="IGHV-U\n trisomy 12"))+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     comparisons = list( c(1,2), c(3,4), c(1,3)),
                     size=3)+
  xlab("") +
  ylab("Log(Viability)") +
  ggtitle("Resiquimod") +
  scale_color_manual(values=c(colors[1], colors[2])) + 
  coord_cartesian(ylim = c(-1.5, 3.1), clip="off") +
  t1+
  theme(axis.text.x = element_text(angle = 45, vjust =1))


```

In addition to trisomy 12, I noted that TLR stimulation also increased viability in samples with mutations in the DNA damage response pathway, namely del(11q), del(17p), and *ATM* and *TP53*. Del(17p) occurs in 7% of CLL cases and is associated with loss of TP53, a tumour suppressor gene involved in DNA damage and repair [@Zenz2010]. Del(11q) is more common (18% of cases) and is associated with loss of ATM, another protein involved in DNA repair[@Kipps2017]. This suggests that there may also be cross-talk between the TLR and DNA damage response pathway, and that this affects the outcome of TLR stimulation. 

The effect of TLR stimulation on CLL viability is dependent on the molecular make-up of the tumour. The nature of TLR response may also be important in prognosis, underlined by our the observation in section \@ref(clustering) that a subgroup of patients (C3) shows slower disease progression, and is the only group in which TLR induces apoptosis. The role of TLR signalling in pathogenesis and prognosis may thus so far be under appreciated. 

Collectively, this work represents the first large-scale attempt to profile the integrative effects of cell-extrinsic signals and cell-intrinsic features in lymphoma on a large scale. This systematic approach highlighted trisomy 12  as the most common feature to modulate responses. The rest of this chapter outlines my work to investigate the role of trisomy 12 in microenvironmental response. 


## Investigating Trisomy 12 as a modulator of microenvironmental response
### Trisomy 12 is a modulator of microenvironmental response {#trisomy12-modulator}
Trisomy 12 modulated responses to IL4, TGF$\beta$, soluble CD40L + IL4 and TLR stimuli (Bruch & Giles et al. 2021, Figure \@ref(fig:tri12cytResponse)). For example, the increase in viability induced by IL4 was enhanced in trisomy 12 samples, as was the decrease in viability in response to TGF$\beta$ stimulation. 

Trisomy 12 is commonly mutated in CLL (15% of patients)[@Dohner2000]. Until recently, this genetic lesion was regarded as conferring intermediate risk, though novel therapies have improved outcomes for trisomy 12 patients [@Bosch2019]. However, the functional explanation for its recurrence is incompletely understood. Previous work has shown a role for gene dosage effects in the pathogenic mechanism: @Kienle2005 show that overexpression of genes including CDK4 and E2F1 leads to increased cell cycling and higher proliferative capacity. Likewise, @HerbstThesis showed that BCR signalling proteins are also upregulated, which may also contribute to the increased proliferative capacity. Despite this, outcomes in trisomy 12 CLL are more favourable, and these cases show increased susceptibility to BCR inhibition [@JCIpaper] (see also, section \@ref(intro-trisomy12)).

In the following, I outline my work to investigate the incompletely understood role of trisomy 12 in CLL.

(ref:tri12cytResponse) Control-normalised log transformed viability values after treatment with IL4, sCD40L + IL4 and TGF$\beta$, stratified by trisomy 12. 

```{r tri12cytResponse, fig.cap='(ref:tri12cytResponse)', message = FALSE,  echo = FALSE, fig.height = 3, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

#add genetic data to viability dataframe
df_patmeta <- left_join(df, patMeta, by = "PatientID")

ii = 
  lapply(c("IL4", "sCD40L + IL4", "TGF\u03B2"), function(x){

df_patmeta %>% 
  dplyr::filter(Cytlabel==x,
                !is.na(trisomy12)) %>%

         
  ggplot(aes(x=trisomy12, y=Log,color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("trisomy 12") +
  ylab("Log(Viability)") +
  ggtitle(x) +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

})

wrap_elements(ii[[1]]) + wrap_elements(ii[[2]]) + wrap_elements(ii[[3]]) 

```

### STAT6, IRAK4 and SMAD3 are more highly expressed in trisomy 12 CLL  {#gene-dosage-effects}
Trisomy 12 samples contain a third copy of chromosome 12: transcriptomic and proteomic profiling of CLL samples with this lesion have demonstrated that this has a major impact on gene expression and protein abundances [@Abruzzo2018; @HerbstThesis; @MeierAbt2021]. It has also been shown that BCR signalling proteins are amongst those with increased expression in trisomy 12 [@HerbstThesis], and this is thought to contribute to increased susceptibility to BCR inhibition in trisomy 12 CLL [@JCIpaper]. 

Guided by this observation, I began by investigating RNA and protein expression levels amongst genes involved in the TGF$\beta$, IL4 and TLR pathways, to which trisomy 12 samples respond more strongly. The aim was to determine whether proteins in these pathways are more abundant in trisomy 12 CLL, thus contributing to the enhanced response.  

I ran differential expression analysis to compare CLL samples from the screen with and without trisomy 12. Next, I filtered the differentially expressed genes (adjusted p < 0.1) for those belonging to the TGF$\beta$, JAK-STAT and TLR pathways genesets, from the KEGG database. I visualised the RNA counts and protein abundances [@HerbstThesis] for those genes. 

Only a small proportion of the differentially expressed genes belonged to the TGF$\beta$, JAK-STAT and TLR pathways genesets. However of those that were, several genes were key downstream mediators of these pathways (Figure \@ref(fig:geneDosage). Amongst TGF$\beta$ signalling genes, 7 / 95 were upregulated in trisomy 12, including SMAD3. 12 / 160 IL4 signalling genes were differentially expressed, including STAT2.  Only 2 / 116 genes in the TLR geneset were differentially expressed, though this included IRAK4 on chromosome 12. Amongst these key mediators SMAD3, STAT2, and IRAK4, all showed higher protein abundance in addition to increased RNA expression. Notably, STAT6, the key downstream mediator of IL4 signalling,  was not differentially expressed, but also showed differential protein abundance. Interestingly, many of the over-expressed genes are not located on chromosome 12, indicating the extent to which the differential dosage of this chromosome has on the expression of the entire genome. 

(ref:geneDosage) Beeswarm-boxplots showing RNA counts and protein abundances stratified by trisomy 12 status. P values from Student's t-test. _Proteomics dataset  from @HerbstThesis_ Method: \@ref(gene-dosage-effects-method).
```{r prepgeneDosage}

#get table to convert between IDS
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", version="90")
transAnno <- getBM(attributes=c('ensembl_gene_id','hgnc_symbol','chromosome_name', 'transcript_biotype'), mart = ensembl)
transAnno <- dplyr::filter(transAnno, hgnc_symbol != "")
id2gene <- dplyr::select(transAnno, ensembl_gene_id, hgnc_symbol)

```

```{r geneDosage, fig.cap='(ref:geneDosage)', message = FALSE,  echo = FALSE, fig.height = 8, fig.width = 6,  fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

##SMAD 3
data <- plotCounts(dds_smp, gene="ENSG00000166949", #SMAD3
                   intgroup=c("trisomy12"), 
                   returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
data$data_type <- "rna"
data$gene <- "SMAD3"

    
df_tbl_prot <- 
  wideFormat(multiomics_MAE["SMAD3",,"proteomics"] ) %>% as_tibble()

colnames(df_tbl_prot)[2] <- "protein"

mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]

df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
colnames(df_tbl_SNP)[2] <- "alteration"
df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" ) %>% column_to_rownames("primary")
colnames(df_tbl) <- c("count", "trisomy12")
df_tbl$data_type <- "proteomics"
df_tbl$gene <- "SMAD3"


#join 
facetPlot <- rbind(data,df_tbl)

#STAT6
data <- plotCounts(dds_smp, gene="ENSG00000166888", #STAT6
                   intgroup=c("trisomy12"), 
                   returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
data$data_type <- "rna"
data$gene <- "STAT6"

    
df_tbl_prot <- 
  wideFormat(multiomics_MAE["STAT6",,"proteomics"] ) %>% as_tibble()

colnames(df_tbl_prot)[2] <- "protein"

mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]

df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
colnames(df_tbl_SNP)[2] <- "alteration"
df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" ) %>% column_to_rownames("primary")
colnames(df_tbl) <- c("count", "trisomy12")
df_tbl$data_type <- "proteomics"
df_tbl$gene <- "STAT6"

facetPlot <- rbind(facetPlot, data, df_tbl)


#STAT2
data <- plotCounts(dds_smp, gene="ENSG00000170581", #STAT6
                   intgroup=c("trisomy12"), 
                   returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
data$data_type <- "rna"
data$gene <- "STAT2"

    
df_tbl_prot <- 
  wideFormat(multiomics_MAE["STAT2",,"proteomics"] ) %>% as_tibble()

colnames(df_tbl_prot)[2] <- "protein"

mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]

df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
colnames(df_tbl_SNP)[2] <- "alteration"
df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" ) %>% column_to_rownames("primary")
colnames(df_tbl) <- c("count", "trisomy12")
df_tbl$data_type <- "proteomics"
df_tbl$gene <- "STAT2"

facetPlot <- rbind(facetPlot, data, df_tbl)



#IRAK4
data <- plotCounts(dds_smp, gene="ENSG00000198001", #STAT6
                   intgroup=c("trisomy12"), 
                   returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
data$data_type <- "rna"
data$gene <- "IRAK4"

    
df_tbl_prot <- 
  wideFormat(multiomics_MAE["IRAK4",,"proteomics"] ) %>% as_tibble()

colnames(df_tbl_prot)[2] <- "protein"

mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]

df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
colnames(df_tbl_SNP)[2] <- "alteration"
df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" ) %>% column_to_rownames("primary")
colnames(df_tbl) <- c("count", "trisomy12")
df_tbl$data_type <- "proteomics"
df_tbl$gene <- "IRAK4"

facetPlot <- rbind(facetPlot, data, df_tbl)
facetPlot <- facetPlot[!is.na(facetPlot$trisomy12), ]


labs <- c("RNA", "Protein")
names(labs) <- c("rna", "proteomics")

#Make plot 
ggplot(facetPlot, aes(x = trisomy12, y = count, color=trisomy12)) +
      geom_boxplot() +
      geom_beeswarm() + 
      facet_wrap(gene ~ data_type, scales = "free", nrow = 2, labeller = labeller(data_type = labs)) +
      ylab("Counts") +
      xlab("trisomy 12") +
      
      t2 +
      scale_color_manual(values = c(colors[1], colors[2])) +
      theme(legend.position = "none") +
      
      stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
  
```

Next I looked for further evidence to directly link the higher gene dosage of cytokine signalling genes, to enhanced responses to cytokine signals. 

### Classification analysis identifies trisomy 12 phenocopies that show increased expression of IRAK4 and SMAD3 {#trisomy12-classifier}
I next investigated whether any non-trisomy 12 samples might display a trisomy 12-like phenotype (referred to as a phenocopy), in that they respond in a similar way to the panel of stimuli. The aim was to identify trisomy 12 phenocopies and to isolate the feature of these samples that might explain the underlying cause of enhanced response to external signals in trisomy 12 CLL.  In particular, I was interested to see if these phenocopies showed higher expression, or even gene amplification, of the signalling genes identified in section  \@ref(gene-dosage-effects). 

To identify trisomy 12 phenocopies, I began by generating a classifier to predict the trisomy 12 status of a sample from its stimulus response matrix. I aimed to find non-trisomy 12 samples that were consistently misclassified as trisomy 12.

The classifier was built using binomial regression, with lasso penalisation,  as implemented in the `R` package `glmnet` [@R-glmnet]. The feature matrix consisted of z scores of the viability values after treatment with each stimulus, and was used to predict the response (trisomy 12 status). I ran the model for 50 bootstrapped repeats, using  three-fold cross-validation and mean absolute error as loss. Resiquimod, sCD40L+IL4 and TGF$\beta$ were selected as coefficients that predict trisomy 12 status (Figure \@ref(fig:tri12Classfier), as would be expected bed on the observations in section \@ref(trisomy12-modulator).

(ref:tri12Classifier) Predictor profile showing coefficients selected as predictors of trisomy 12 status. Here, binomial modelling with L1-penalty was used to identify associations between responses to stimuli and trisomy 12 status. Bar plots (left) show size and sign of assigned coefficients named on the right. A positive coefficient indicates that higher viability upon treatment named stimulus is associated with trisomy 12. Facet labels (top) and corresponding heatmap below show how the viability with each named stimulus relates to trisomy 12 status. The model shown was selected from 50 bootstrapped repeats, based on maximal AUC. Method \@ref(trisomy12-classifier-method). 

```{R phenocopyPrework}
########### Viability matrix ################
#make viability matrix for cytokine treatments for patients
cyt_viab <- dplyr::select(df, 
                PatientID, 
                Log, 
                Cytokine) %>% spread(Cytokine, Log) %>% as.data.frame()

#make PatID the row names
rownames(cyt_viab) <- unlist(cyt_viab[,1]) # the first row will be the header
cyt_viab <- dplyr::select(cyt_viab,-PatientID) 

cyt_viab <- t(cyt_viab)

#run scaleCytResp on viability matrix
x <- scaleCytResp05(cyt_viab)
x <-t(x)


## Response matrix 
#Get Tri 12 status
y <- dplyr::select(patMeta, PatientID, trisomy12) %>% dplyr::filter(!is.na(trisomy12)) %>% column_to_rownames("PatientID")

y$trisomy12 <- as.numeric(as.character(y$trisomy12))

y <- t(y)

#Remove NA patients from viability matrix
x <- x[colnames(y),]


# Run logistic regression
X <- x

#set whether to spilt data into test and training set
testRatio = FALSE

#set parameters for running model
repeats <- 50
folds <- 3

if(testRatio){
  
  glmRes <- runGlm.bin(X,as.integer(y), repeats = repeats, folds =folds, testRatio = 0.3)
  
}else{
  
  glmRes <- runGlm.bin(X, as.integer(y), repeats = repeats, folds = folds, testRatio = NULL)}



## ROC of best model
if(testRatio){
iBest <- which.max(glmRes$aucCV)
glmRes$rocTest[[iBest]]
}else{
  iBest <- which.max(glmRes$aucCV)
}

```


```{r tri12Classifier, fig.cap='(ref:tri12Classifier)', message = FALSE,  echo = FALSE, fig.height=3, fig.width = 8, fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

X.scale <- X

p <- lassoPlot_bin(glmRes, X.scale, y,freqCut = 0, coefCut = 0.01, modelIndex = iBest, rowHeight = 0.001)

grid.arrange(p)

```

I then predicted trisomy 12 status with the same viability matrix, using each of the 50 bootstrapped. I compared the results of the classification with the true trisomy 12 status. Two patient samples were misclassified as trisomy 12 in more than 50% of repeats; I refer to these as patient sample A and B in the below. Patient sample A showed the lowest viability with TGF$\beta$ (Figure \@ref(fig:tri12PhenocopiesCytResponse), and Patient sample B showed the highest viability with IL4, and the second highest with Resiquimod.  

(ref:tri12PhenocopiesCytResponse) Control-normalised log-transformed viability values, for all samples after treatment with Resiquimod, sCD40L + IL4 and TGF$\beta$. Patient sample A and B are indicated in blue and red, respectively. 

```{r tri12PhenocopiesCytResponse, fig.cap='(ref:tri12PhenocopiesCytResponse)', message = FALSE,  echo = FALSE, fig.height=3, fig.width = 3, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}


plotTab <- filter(df, Cytokine%in% c("Resiquimod", "sCD40L+IL-4", "TGF-b1"))
plotTab %>%
  ggplot(aes(x=Cytokine,
             y=Log)) + 
  geom_boxplot(fill=NA) +
  geom_beeswarm(cex=0.3, alpha=0.4, color= lightergrey) +
  t2 +
  ylab("Log(Viability") + xlab("")+
  geom_point(data=dplyr::filter(plotTab, PatientID =="Pat_033"), aes(x=Cytokine, y=Log), colour=palblues[1], size=2) + 
    geom_point(data=dplyr::filter(plotTab, PatientID =="Pat_114"), aes(x=Cytokine, y=Log), colour=palreds[8], size=2) + scale_x_discrete(labels = c("Resiquimod" = "Resiquimod", "sCD40L+IL-4" = "sCD40L \n+ IL4", "TGF-b1" = "TGF-\u03B21"))


```
I next investigated whether either of these non-trisomy 12 samples contained any regional amplifications on chromosome 12, which may help to isolate the gene(s) causing the tumour to respond more strongly to these signals. The whole exome sequencing for both patient samples indicated that Patient sample A had several amplified regions at 12p13.31 (42 copies), 12q24.13 (10 copies) and 12q24.33 (21 copies).  An examination of the genes in these regions indicated that none of the signalling genes identified in  \@ref(gene-dosage-effects) could be found in these regions, and no clear candidate gene(s) emerged that may be involved in responses to external signals. 

In the absence of gene amplification, I next checked patient samples A and B might show higher expression of the  signalling genes identified in  \@ref(gene-dosage-effects) by visualising the RNA expression levels for SMAD3, IRAK4 and STAT6 for these patients (Figure \@ref(fig:tri12PhenocopiesRNA). Patient sample A, which responded most strongly to Resiquimod, showed high levels of IRAK4 compared to the other non-triomsy 12 samples. Patient sample B, which responded strongly to TGF$\beta$ showed the highest level of SMAD3 expression amongst the non-trisomy 12 samples. Thus, whilst neither patient sample contained an amplicon of SMAD3 or IRAK4,  its possible that increased expression of these proteins enables a stronger response to the corresponding pathway.

(ref:tri12PhenocopiesRNA) Raw RNA counts for SMAD3, IRAK4 and STAT6, stratified by trisomy 12 status. Patient sample A and B are indicated in blue and red, respectively. P values from Student's t-test. 

```{r tri12PhenocopiesRNA, fig.cap='(ref:tri12PhenocopiesRNA)', message = FALSE,  echo = FALSE,fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

genes <- c(
           "ENSG00000166888", #STAT6
           "ENSG00000198001", #IRAK4
           "ENSG00000166949" #SMAD3
           )
RNAplots <- 
lapply(genes, function(x){
  data <- plotCounts(dds_smp_full, gene=x, intgroup=c("trisomy12"), returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1")) %>% rownames_to_column("PatientID")
    
    #get hgnc symbol from ENS id
    gene_name <-
    as.data.frame(rowData(dds_smp_full)) %>% 
    rownames_to_column("ensembl_gene_id") %>%
    filter(ensembl_gene_id == x) %>%
    dplyr::select(symbol)
    
    #Make plot
    ggplot(data, aes(x = trisomy12, y = count, color = trisomy12)) +
      geom_boxplot() +
      geom_beeswarm() + 
      ggtitle(gene_name) +
      ylab("Counts") +
      xlab("trisomy 12") +
      
      t2 +
      scale_color_manual(values = c(colors[1], colors[2])) +
      theme(aspect.ratio=1,  text = element_text(size = 15), legend.position = "none") +
      
      stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size = 3) + 
      
      geom_point(data=dplyr::filter(data, PatientID =="Pat_114"), aes(x=trisomy12, y=count), colour=palreds[8], size=2) +
      geom_point(data=dplyr::filter(data, PatientID =="Pat_033"), aes(x=trisomy12, y=count), colour=palblues[1], size=2)
      
})

RNAplots[[1]] + RNAplots[[2]] + RNAplots[[3]] 


```

These results collectively suggest that increased gene dosage of key genes in the IL4, TLR and TGF$\beta$ pathways may underlie the increased response of trisomy 12 samples to these pathways. This is also reflected in the patient samples A and B, which responded more strongly to the TGF$\beta$ and TLR pathways, respectively, and correspondingly higher levels of SMAD3 and STAT6 proteins. However, computational techniques can only go to far in providing biological proof, and more work is needed here to confirm this finding. In addition to gene dosage effects, I also investigated differences in transcription factor activity in trisomy 12. The results of this warranted further follow up, and this forms the focus of rest of this chapter. 

###  Spi-B and PU.1 TFs show higher activity in trisomy 12 CLL
Trisomy 12 has been well-studied at both the transcriptomic and proteomic level, and yet the cause of its recurrence in CLL is not fully understood. Thus, I next decided to investigate the impact of trisomy 12 on the epigenetic landscape of CLL, which is less well studied. In particular, I wanted to investigate differential transcription factor activity in CLL, which would give an indicator of which pathways are differentially active. 

We acquired two independent ATAC sequencing datasets. The first, generated and processed in our lab, consisted of two WT and two trisomy 12 samples (Bruch & Giles et al. 2021). The second, taken from @Rendeiro2017 and processed in our lab, comprised 43 WT and nine trisomy 12 samples. 

In the external dataset, trisomy 12 status was not annotated. To do this, we used the ATACseq reads to call trisomy 12 in samples that contained > 1.4 times more reads per peak (i.e. genomic region) on average in chromosome 12, compared to peaks on other chromosomes. 

Next, we used the `R` package `diffTF` [@R-diffTF] to identify TFs that showed differential binding site accessibility between the WT and trisomy 12 samples (Figure \@ref(fig:diffTFexplainer). `diffTF` enables comparison of TF activity between two conditions, using chromatin accessibility data, see section \@ref(intro-ATACseq). We provided a list of 636 TFs, from the HOCOMOCO v10 database [@HOCOMOCO] to measure their change in actiitvy between trisomy 12 and WT samples (Bruch & Giles et al. 2021). 

(ref:diffTFexplainer) diffTF workflow from @Berest2019. diffTF accepts a list of TFs along with the genomic locations of their bindings sites. For each TF, the software computes the distribution of fold changes between the trisomy 12 and WT samples, using the ATACseq peaks at each TF binding site in each condition. The software compares this distribution to a background set of fold changes generated using GC content-matched loci that do not contain the same TF binding site motif. Each TF is thus assigned assigned a weighted mean difference value, which quantifies the change in activity, and a p value.

```{r diffTFexplainer, fig.cap='(ref:diffTFexplainer)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '50%', dev = 'cairo_pdf'}

knitr::include_graphics("figures/diffTF_method.eps")

```

Running this analysis on both ATACseq datasets indicated that the binding sites of nine TFs  were more accessible (p<0.05) in the trisomy 12 samples of the larger, external dataset (Figure \@ref(fig:tri12diffTF). In the smaller in-house dataset, the binding sites of 92 TFs were likewise more accessible (Supp. Figure \@ref(fig:diffTFsmallvolPlot)). RNA and proteomics data show different abundances of transcripts and proteins in trisomy 12 CLL: ATACseq data here shows that this also corresponds to a specific signalling signature in trisomy 12 CLL. 

We confirmed that the results were not affected by the additional copy of chromosome 12.  Rerunning diffTF analysis without the ATACseq reads from chromosome 12 had minor impact on the significant TFs. 

In both datasets, the TFs with the largest increase in activity in trisomy 12  were Spi-B and/or PU.1 (Bruch & Giles et al. 2021). Both TFs share similar binding motifs and exhibit functional redundancy [@GarrettSinha2001], which make it difficult to distinguish from ATACseq data alone whether either or both are more active. 

Spi-B and PU.1  are haematopoetic regulators that are known to be key regulators of healthy B-cell function [@Turkistany2011][READ MORE], controlling B-cell responses to environmental cues including CD40L, TLR ligands and IL4 [@Willis2017].

(ref:tri12diffTF) Bar plot showing the results of the diffTF analysis for the @Rendeiro2016 dataset. y axis shows change in TF activity (weighted mean difference)  between trisomy 12 (n = 9) and non-trisomy 12 samples (n = 43),x axis indicates TF names. 17 / 636 TFs, with BH adjusted p <0.05 are shown. p values generated by diffTF in permutation mode. TF binding sites defined in HOCOMOCO v10 [@HOCOMOCO].

```{r tri12diffTF, fig.cap='(ref:tri12diffTF)', message = FALSE,  echo = FALSE,fig.height=6, fig.width=8, fig.align="center", out.width = '80%', dev = 'cairo_pdf'}


#Get all TFs that show differential activity
plotTab.diffTF <- dplyr::filter(diffTF_large, pvalueAdj < 0.05)
#change to name of TF quoted in text
plotTab.diffTF$TF <- gsub("SPI1", "PU1", plotTab.diffTF$TF)
#order by weighted mean difference
idx <- order(plotTab.diffTF[["weighted_meanDifference"]], decreasing = TRUE)
plotTab.diffTF$TF <- factor(plotTab.diffTF$TF,levels=rev(unique(plotTab.diffTF$TF[idx])))
#plot figure

  ggplot(plotTab.diffTF,
         aes(x=weighted_meanDifference,
             y=TF,
             fill= ifelse(weighted_meanDifference>0, 
                          palreds[5], palblues[1]))) +
  geom_bar(stat = "identity", width = 0.75) +
  xlim(c(-0.2, 0.175)) +
  
  #colours and theme
  scale_fill_manual(values = c(palblues[1], palreds[8]), guide = "none") +
  t1 + 
  theme(axis.text.x = element_text(angle = 45, vjust =1))+
  
  #Labels
  ylab("") + 
  xlab("Change in TF activity") +
  ggtitle("Diffential TF activity in trisomy 12 CLL") + 
  
  #Add annotations
  #arrow 1
  annotate("segment", x = -0.15, xend = -0.15, y = 8.4, yend = 0.75, 
           colour = "#5e5e5e", size=3, alpha=1, arrow=arrow()) + 
  #arrow 2
  annotate("segment", x = -0.15, xend = -0.15, y = 8.6, yend = 17, 
           colour = "#5e5e5e", size=3, alpha=1, arrow=arrow()) + 
 
   #2 arrow labels
  annotate("text", x = c(-0.185,-0.185), y = c(4.8,12.5), 
          label = c("Lower activity in trisomy 12 CLL", 
                    "Higher activity in trisomy 12 CLL") , 
          color="black", 
          size=5 , fontface="bold") +
  #flip plot
  coord_flip() 

```

Spi-B and PU.1 appeared to be upregulated in trisomy 12 CLL, and evidence in the literature indicated that these may regulate environmental sensing genes, providing a link between trisomy 12, and enhanced responses to external signals. 

To provide further evidence of this, I next aimed to profile the downstream effects of Spi-B and PU.1 in lymphoma. 

### Spi-B and PU.1 targets are enriched for immune signalling pathways
I hypothesised that Spi-B and PU.1 might coordinate transcriptional response to external signals, thus modulating CLL proliferation in response to the microenvironment. To identify Spi-B and PU.1 target genes specifically  in lymphoma, I acquired a ChIPseq dataset [@Care2014] containing data on Spi-B and PU.1 binding in lymphoma cell lines. I used this dataset to test for functional enrichment of immune signalling pathways amongst the TF targets. 

To define TF targets, I took the closest gene to each significant ChIP peak (q value<0.05), and within $\pm$kb of TSS. I then tested for over-representation of these TF targets amongst selected KEGG[@KEGG] and Reactome [@Reactome] genesets, using the 'R' package `clusterProfiler` [@R-clusterProfiler]. This method corresponded to a one-sided version of Fisher's exact test. This analysis showed TLR, BCR and TGF$\beta$ signalling genes to be enriched (p<0.01) amongst Spi-B and PU.1 targets (Figure \@ref(fig:SpiBChipSeq)).

(ref:SpiBChipSeq) Table shows results from over-representation tests of selected KEGG and Reactome pathways amongst Spi-B and PU.1 targets. Columns show geneset pathways, corresponding database, the number of genes within geneset, the number of Spi-B and PU.1 target genes within geneset (total number of target genes defined also shown), and p-value from over-representation test. TF targets defined as closest gene to each significant ChIP peak (q value<0.05), and within $\pm$1kb of TSS. ChIPseq data from @Care2014. Over-representation tests run using [@clusterProfiler] package, method corresponds to one-sided version of Fisherâ€™s exact test. _Figure and caption from Bruch & Giles et al 2021._
```{r SpiBChipSeq, fig.cap='(ref:SpiBChipSeq)', message=FALSE,  results = 'hide', echo = FALSE, fig.height=2, fig.width = 15, fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

#Get significant peaks
#filter ChipSeq data for peaks with significant score -log10(Qscore)>1.3
#if q < 0.05, then Qlog >1.3
spib.filtered <- peak.spib[(elementMetadata(peak.spib)[,1] > 1.3)]
pu1.filtered <- peak.pu1[(elementMetadata(peak.pu1)[,1] > 1.3)]


# Annotate peaks with meta data
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
peakAnno.spib <- annotatePeak(spib.filtered, 
                              tssRegion = c(-3000, 3000),
                              TxDb = txdb, 
                              annoDb = "org.Hs.eg.db")
peakAnno.pu1 <- annotatePeak(pu1.filtered, 
                             tssRegion = c(-3000, 3000),
                             TxDb = txdb, 
                             annoDb = "org.Hs.eg.db")
#Filter for genes within Â±1kb
peakAnno.spib.1kb <- as.data.frame(peakAnno.spib) %>% dplyr::filter(abs(distanceToTSS) <1000)
peakAnno.pu1.1kb <- as.data.frame(peakAnno.pu1) %>% dplyr::filter(abs(distanceToTSS) <1000)

#get  KEGG pathways from msigdbr database
kegg <- 
  msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG") %>% 
  #select pathway name and entrez id 
  dplyr::select(gs_name, entrez_gene)
#subset for pathways that we want to test
kegg <-
  dplyr::filter(kegg, 
         #All KEGG immune signaling pathways
         gs_name %in% c("KEGG_B_CELL_RECEPTOR_SIGNALING_PATHWAY",
                        "KEGG_CHEMOKINE_SIGNALING_PATHWAY",
                        "KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION", 
                        "KEGG_JAK_STAT_SIGNALING_PATHWAY" ,
                        "KEGG_NOD_LIKE_RECEPTOR_SIGNALING_PATHWAY"  , 
                        "KEGG_NOTCH_SIGNALING_PATHWAY", 
                        "KEGG_RIG_I_LIKE_RECEPTOR_SIGNALING_PATHWAY", 
                        "KEGG_TOLL_LIKE_RECEPTOR_SIGNALING_PATHWAY",
                        "KEGG_T_CELL_RECEPTOR_SIGNALING_PATHWAY",
                        #Control genesets
                        "KEGG_OXIDATIVE_PHOSPHORYLATION",                  
                        "KEGG_DNA_REPLICATION"
         ))
colnames(kegg) <- c("term", "gene")
#tidy up terms - remove KEGG, underscore and put in lower cases
kegg$term <- gsub("KEGG_", "",kegg$term )
kegg$term <- gsub("_", " ",kegg$term )
kegg$term <- gsub("B CELL RECEPTOR SIGNALING PATHWAY", 
                  "BCR Signaling Pathway",kegg$term )
kegg$term <- gsub("CHEMOKINE SIGNALING PATHWAY", 
                  "Chemokine Signaling Pathway",kegg$term )
kegg$term <- gsub("CYTOKINE CYTOKINE RECEPTOR INTERACTION", 
                  "Cytokine Cytokine Receptor Interaction",kegg$term )
kegg$term <- gsub("JAK STAT SIGNALING PATHWAY", 
                  "JAK STAT signaling pathway",kegg$term )
kegg$term <- gsub("NOD LIKE RECEPTOR SIGNALING PATHWAY", 
                  "NLR Signaling Pathway",kegg$term )
kegg$term <- gsub("NOTCH SIGNALING PATHWAY", 
                  "Notch Signaling Pathway",kegg$term )
kegg$term <- gsub("RIG I LIKE RECEPTOR SIGNALING PATHWAY", 
                  "RLR Signaling Pathway",kegg$term )
kegg$term <- gsub("TOLL LIKE RECEPTOR SIGNALING PATHWAY", 
                  "TLR Signaling Pathway",kegg$term )
kegg$term <- gsub("T CELL RECEPTOR SIGNALING PATHWAY", 
                  "TCR Signaling Pathway",kegg$term )
kegg$term <- gsub("OXIDATIVE PHOSPHORYLATION", 
                  "Oxidative Phosphorylation",kegg$term )
kegg$term <- gsub("P53 SIGNALING PATHWAY", 
                  "P53 Signaling Pathway",kegg$term )
kegg$term <- gsub("DNA REPLICATION", 
                  "DNA Replication",kegg$term )
kegg$genesetDatabase <- "KEGG"
#get reactome pathways
reactome <- 
  msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:REACTOME") %>% 
  #select pathway name and entrez id
  dplyr::select(gs_name, entrez_gene)
#subset for pathways that we want to test
reactome <-
  dplyr::filter(reactome, 
         gs_name %in% c(#selected immune pathways
                        "REACTOME_SIGNALING_BY_TGF_BETA_RECEPTOR_COMPLEX",
                        "REACTOME_TNF_SIGNALING",
                        "REACTOME_INTERLEUKIN_1_SIGNALING",
                        "REACTOME_INTERLEUKIN_10_SIGNALING",
                        "REACTOME_INTERLEUKIN_15_SIGNALING",
                        "REACTOME_INTERLEUKIN_2_SIGNALING",
                        "REACTOME_INTERLEUKIN_4_AND_INTERLEUKIN_13_SIGNALING",
                        "REACTOME_INTERLEUKIN_6_SIGNALING" ,
                        "REACTOME_OTHER_INTERLEUKIN_SIGNALING",
                        "REACTOME_SIGNALING_BY_INTERLEUKINS",
                        "REACTOME_INTERFERON_ALPHA_BETA_SIGNALING" ,
                        "REACTOME_INTERFERON_GAMMA_SIGNALING", 
                        #Control genesets
                        "REACTOME_CELL_CYCLE",                  
                        "REACTOME_REGULATION_OF_TP53_ACTIVITY" 
                        ))
colnames(reactome) <- c("term", "gene")
#tidy up terms
reactome$term <- gsub("REACTOME_", "",reactome$term )
reactome$term <- gsub("_", " ",reactome$term )
#tidy up and put in lower case
reactome$term <- gsub("CELL CYCLE", 
                      "Cell Cycle",reactome$term )
reactome$term <- gsub("INTERLEUKIN 1 SIGNALING", 
                      "Interleukin 1 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 10 SIGNALING", 
                      "Interleukin 10 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 15 SIGNALING", 
                      "Interleukin 15 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 2 SIGNALING", 
                      "Interleukin 2 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 4 AND INTERLEUKIN 13 SIGNALING", 
                      "Interleukin 4 and Interleukin 13 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 6 SIGNALING",
                      "Interleukin 6 Signaling",reactome$term )
reactome$term <- gsub("OTHER INTERLEUKIN SIGNALING", 
                      "Other Interleukin Signaling",reactome$term )
reactome$term <- gsub("SIGNALING BY INTERLEUKINS", 
                      "Signaling by Interleukins",reactome$term )
reactome$term <- gsub("REGULATION OF TP53 ACTIVITY", 
                      "Regulation of TP53 Pathway",reactome$term )
reactome$term <- gsub("SIGNALING BY TGF BETA RECEPTOR COMPLEX",
                      "Signaling by TGFbeta \nReceptor Complex", reactome$term )
reactome$term <- gsub("TNF SIGNALING", 
                      "TNF Signaling",reactome$term )
reactome$term <- gsub("INTERFERON ALPHA BETA SIGNALING", 
                      "Interferon Alpha Beta Signaling",reactome$term )
reactome$term <- gsub("INTERFERON GAMMA SIGNALING", 
                      "Interferon Gamma Signaling", reactome$term )
#annotate which database these pathways come from 
reactome$genesetDatabase <- "Reactome"


#Run over-representation test forSPIB

#generate TERM2GENE dataframe to use in overrepresetation test
#join kegg and reactome gene sets together - this defines the list of pathways we are interested in, and select term and gene columns
term2gene <- rbind(kegg, reactome) %>% dplyr::select(term, gene)
#term2genesetdatabase - keep details of database source for each pathway 
term2genesetdatabase <- rbind(kegg, reactome) %>% dplyr::select(term, genesetDatabase)
colnames(term2genesetdatabase) <- c("term", "name")
##SPIB
#run over-representation test, and extract all results and p values:
#NB Bg ratio = number of genes in set / number of unique genes in term2gene, 
#NB Gene ratio = number of SPIB targets in gene set being tested / total number of SPIB targets that overlap with genes in term to gene
spibRes <- enricher(unique(as.data.frame(peakAnno.spib.1kb)$geneId), 
                    #Use pathways in term2gene
                    TERM2GENE=term2gene, 
                    #assign description for each term, as its database source
                    TERM2NAME = term2genesetdatabase, 
                    #no cutoffs on reported results, we want to see all results and p values 
                    minGSSize = 0,
                    maxGSSize = 1000,
                    pvalueCutoff = 1, 
                    qvalueCutoff = 1)
#get dataframe of results
spibRes.df <- fortify(spibRes, 
              showCategory = length(unique(term2gene$term)), #show all pathways tested
              split=NULL)
resTab.spib <-  
  mutate(spibRes.df, genesetSize = BgRatio*length(unique(term2gene$gene))) %>%  #multiply BgRatio by total genes tested to get number of genes in set
  dplyr::select(ID, Description, pvalue, Count, genesetSize)
colnames(resTab.spib) <- c("ID", "genesetDatabase", "pvalue_SPIB","count_SPIB", "genesetSize")


#Run over-representation test for PU1

##PU1
#run overepresentation test, and extract all results and pvalues (ie use p value and q value cutoff at 1) 
#NB not all results are shown because for some genesets there is no overlap between pu1 targets and geneset
pu1Res <- enricher(unique(as.data.frame(peakAnno.pu1.1kb)$geneId), 
                    TERM2GENE=term2gene, 
                    TERM2NAME = term2genesetdatabase, 
                    minGSSize = 0,
                    maxGSSize = 10000,
                    pvalueCutoff = 1, 
                    qvalueCutoff = 1)
#get dataframe of results
pu1Res.df <- fortify(pu1Res, 
              showCategory = length(unique(term2gene$term)), #show all pathways tested 
              split=NULL)
resTab.pu1 <-  mutate(pu1Res.df, genesetSize = BgRatio*length(unique(term2gene$gene))) %>%  #multiply BgRatio by total genes tested to get number of genes in set
  dplyr::select(ID, Description, pvalue, Count, genesetSize)
colnames(resTab.pu1) <- c("ID", "genesetDatabase", "pvalue_PU1","count_PU1", "genesetSize")


#join results for SPIB and PU1 together to show in one table
resTab <- full_join(resTab.spib, resTab.pu1)
#where count and p value is NA, put a 0 / 1 (ie there were no PU1/SPIB target genes in the set)
resTab$count_PU1[is.na(resTab$count_PU1)] <- 0
resTab$count_SPIB[is.na(resTab$count_SPIB)] <- 0
resTab$pvalue_SPIB[is.na(resTab$pvalue_SPIB)] <- 1
resTab$pvalue_PU1[is.na(resTab$pvalue_PU1)] <- 1
#select columns of interest to show in figure
resTab <- dplyr::select(resTab, ID, genesetDatabase, genesetSize,  count_SPIB, pvalue_SPIB,count_PU1, pvalue_PU1)
#adjust decimal places of p values
resTab$pvalue_SPIB <- round(resTab$pvalue_SPIB, digits = 3)
resTab$pvalue_PU1 <- round(resTab$pvalue_PU1, digits = 3)
#get significant results
resTab <- dplyr::filter(resTab, pvalue_SPIB<0.01|pvalue_PU1<0.01)
colnames(resTab) <- c("Pathway",
                      "Geneset Database" , 
                      "Geneset Size",  
                      #show the total number of SPIB targets in ChIPseq data 
                      paste("Spi-B targets (/" ,length(unique(as.data.frame(peakAnno.spib.1kb)$geneId)),")", sep= ""), 
                      "SPIB p-value", 
                      #show the total number of PU1 targets in ChIPseq data  
                      paste("PU.1 targets (/" ,length(unique(as.data.frame(peakAnno.pu1.1kb)$geneId)),")",sep= ""), 
                      "PU1 p-value")

ggtexttable(resTab, rows = NULL, 
           theme = ttheme(
             colnames.style = colnames_style(color = "white", fill = palreds[7], size = 16),
             tbody.style = tbody_style(color = "black",size = 18)
           )
)

```


### Double knockdown of Spi-B and PU.1 reduces profileration of trisomy 12+ cell lines
To establish the functional impact of Spi-B and PU.1 inhibition in trisomy 12+ lymphoma, we tested th impact of inhibiting these TFs on proliferation of lymphoma cell lines (Figure \@ref(fig:SpiBshRNAKD). We generated single and double shRNA knockdowns in lymphoma cell lines, namely SU-DHL4 and SU-DHL5 (trisomy 12) and SU-DHL2 (no trisomy 12) and then measured cell counts at 24 hour intervals (Bruch & Giles et al. 2021). 

(ref:SpiBshRNAKD) Knockdown of Spi-B and PU.1 led to growth restriction and cell death. Data shown is the mean of three technical replicates. While SU-DHL 5 was already growth impaired after Spi-B KD, SU-DHL 2 and SU-DHL 4 were only impaired after double knock-down. Double knockdown lead to rapid cell death in SU-DHL 5 (data not shown). Cell count normalised to seeded cell number of diffuse large b cell lymphoma cell lines after knockdown of Spi-B or double knockdown of Spi-B and PU.1 or shRNA as control. _Figure and caption from Bruch & Giles et al. 2021._

```{r SpiBshRNAKD, fig.cap='(ref:SpiBshRNAKD)', message = FALSE,  echo = FALSE, fig.height=4, fig.width = 10, fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


  SPIB_KD_Cellcounts %>% 

  dplyr::filter(treatment%in%c("scr_shRNA", "PU.1-KD","SpiB-KD", "Double-KD")) %>% 
  mutate(treatment=factor(treatment, levels = c("scr_shRNA", "PU.1-KD", "SpiB-KD", "Double-KD"))) %>% 
  
  
  
  ggplot(aes(x=Day, y=NormalizedCellCount, color=treatment, group=interaction( treatment))) +
  stat_summary(fun = mean,geom='line',aes(color=treatment), size=1) +
  stat_summary(fun=mean,geom='point', size=2) +
  facet_wrap(~Cellline, scales="fixed") +
  scale_y_log10() +
  labs(y="Relative Cellcount") +
 t2+
  theme(legend.position = "bottom", legend.key = element_blank(), legend.title = element_text(face='bold', size=fontsize+4),  legend.text = element_text(size=fontsize+2), strip.background = element_blank(), strip.text = element_text(size=18, face="bold"))+
      scale_color_manual(name = "Condition", values = c("darkgrey", colors[c(7,8,3)]), labels=c("scr_shRNA"="Control","PU.1-KD"="PU.1-Knockdown", "SpiB-KD"="Spi-B-Knockdown", "Double-KD"="Spi-B + PU.1 Double Knockdown" ))


```

The single knockdowns had a small impact on proliferation: Spi-B inhibition reduced proliferation in SU-DHL5, as did PU.1 to a lesser extent. Double knockdown of both TFs markedly reduced proliferation in SU-DHL2 and SU-DHL4, and was lethal in SU-DHL5. This result suggested that both these TFs play an important role in the proliferative capacity of the tumour cells, and that there is functional redundancy between Spi-B and PU.1 in this context. 

Collectively, these results demonstrate that trisomy 12 modulates responses to microenvironmental signals. Trisomy 12 appears to increase Spi-B and PU.1 activity, which regulate genes relating to environmental sensing, and reduce proliferation of cell lines when inhibited.

## Summary 
In this chapter, we perform a systematic survey of genetic determinants of microenvironmental response, leading to two key findings. Firstly, TLR signalling has a range of effects on CLL viability, and this is determined by many genetic features, including IGHV status, trisomy 12 and mutation in the DNA Damage Response pathway. Secondly, we identify trisomy 12 as a modulator of microenvironmental response, and show that higher activity of Spi-B and PU.1 may mediate this effect.  

## Discussion
Some do affect, some dont at all 
Notably,  del(13q) and del(17p), which like trisomy 12 and del(11q) are the most common aberrations in CLL and act as prognostic markers [@Dohner2000], had no impact on the responses to the panel of stimuli.
ie some are really affecting signalling, others are not 

TLR and BCR 
@Chatzouli2014 show that stimulation of TLR in IGHV-U samples leads to pronounced p-ERK induction, whereas in M-CLL, stimulation of TLR concomitantly with BCR stimulation is required to induce a smaller increase in p-ERK. TLR stimulation without BCR stimulation in IGHV-M samples leads to an induction of caspase-8 and apoptosis, much more so than in IGHV-U samples[@Chatzouli2014].


TLR as a prognostic tool?<- does this integrate multiple risk markers? 
Reelvance in lymhp node??

Papeer whosing TLR response and survival that i found ages ago 


REad up on trisomy 12
[@Abruzzo2018; @HerbstThesis; @MeierAbt2021, @JCIpaper]. 

Whats knwon about pathogenetic mechanims: 
DOI: 10.1200/JCO.2005.02.568 Journal of Clinical Oncology 23, no. 16 (June 01, 2005) 3780-3792. 

whole chromososm - is it lots of things - IRAK4, STAT6, gen dosge, SPIB and PU1 activity, BCR signalling? 

gene dosage effects are obviosuly quite important here 

the power of bioiformatics techqnieus , as well as traditioanl techinuqes, in bioogical discover, to save time and resouce 

Read up on SpiB and PU1
SPib an dpU 1 regulate BTK: https://pubmed.ncbi.nlm.nih.gov/8934542/
SPIB and PU1 activity in B cells: https://pubmed.ncbi.nlm.nih.gov/15936902/
(hese data indicate that Spi-1 and Spi-B directly regulate the expression of Grap2 and that Grap2 functions to modulate BCR signaling, but that reduced Grap2 expression is unlikely to account for the BCR signaling defects observed in Spi1+/- SpiB-/- B cells.)
PU1 and SPIb and higher in Bc cells- this paper indicates this is to do with SP1 binding (which is on chromosome 12 and is hgiher ) https://pubmed.ncbi.nlm.nih.gov/7566969/
PU1 and PSIb bdinign in mouse lympohma cell ine https://pubmed.ncbi.nlm.nih.gov/25765478/
Spib and PU1 in B and T cell development https://pubmed.ncbi.nlm.nih.gov/8691135/

 
TLR signalling: 
REad [@Chatzouli2014]
TLR stimulation can lead to both acitvation of MAPK and increase in viability or activation of apoptosis. If mutatiosn can affect which pathway is active, this poitns to aditoanl mechsnsim by which these mutations contribtue to CLL drive. It also points to TLR response as a useful prognostic marker. 


POwer of multivariate modellings; 
we need mor ltieracy about these things 
discuovery of mulitple layers of biology rather thatn jsut using t tests 

IL4 and KRAS - IL4 and ERK apthway reading 


BCR singalling - which is important iwtih IHGV and tirsomy 12, is evleated in teh LN accoridng to gene sigantures: 
https://ashpublications.org/blood/article/117/2/563/28102/The-lymph-node-microenvironment-promotes-B-cell


## Contributions statement
The author of this thesis performed statistical inference and regression modelling outlined in this chapter. In essence, she performed the univariate and multivariate survey of genetic determinants of stimulus response. She identified trisomy 12 as a modulator of microenvironmental response, and conceptualised and performed the computational follow-up work on this finding, with support from Peter-Martin Bruch, Ivan Berest and Tina Becirovic. 

This chapter integrates a number of datasets from the following sources. The screening data was generated by Peter-Martin Bruch. The associated patient genetic data, including WES, WGS, CNV profiles, DNA methylation data and RNA was generated and processed by @JCIpaper. The proteomics dataset was generated by @HerbstThesis, and kindly shared for the purpose of this thesis. The larger ATACseq dataset was generated by @Rendeiro2017, and processed by Ivan Berest. The smaller ATACseq dataset was planned by the author and Peter-Martin Bruch, and generated by Peter-Martin Bruch. The data was processed by the author, with support from Ivan Berest. The Spi-B and PU.1 knockdown data was generated by Tina Bericoviv and published in Bruch & Giles et al. 2021.

In addition, the author received support on the following analysis work. Junyan Lu provided advice and support with multivariate modelling approaches. Ivan Berest provided support with running diffTF.

used I versus we and credited datasets, and my paper for figures and factrs - main analysis nad key finding, this hsould be routine 
Then outline in detail at the bottom 

