# Genetic modulators of responses to microenvironmental stimulation
Profiling the effects of the panel of stimuli revealed the heterogenous nature of responses to stimulation. The analysis revealed four  patient sample groups, with distinct responses to the stimuli, unique molecular profiles, and differential disease progression. Two pathways emerged as the most potent modulators of CLL viability, namely IL4 and TLR. These too induced heterogeneous responses across the cohort, in particular stimulation of TLR 7/8/9 increased viability in some samples, whilst it reduced viability in others. 

Next we asked to what extent this heterogeneity of response relates to the molecular profiles of the tumours. We sought to understand which underlying genetic features might modulate responses to external signals, and how these interactions may occur.  We combined the screening dataset with multi-omics profiles of the patient samples taken from the PACE repository[@JCI; R-BloodCancerMultiOmics2017] and performed a systematic survey of molecular determinants of stimulus response, using whole-exome sequencing, DNA-methylation, RNA-sequencing and copy number variant data. In addition, for a small subset of patients we also generated  ATAC sequencing and Mass Spectrometry data. 

Collectively, these data enabled us to probe genetic and epigenetic modulators of microenvironmental signalling, in a heterogeneous cohort that encompasses the clinical and molecular diversity of CLL. In the first part of this chapter, I apply a broad systematic approach to identify important genetic modulators, and in the second, I outline the follow-up investigations into specific features of interest. 


```{r, echo = FALSE}

knitr::opts_chunk$set(
   echo = FALSE, 
   message = FALSE, 
   warning = FALSE,
   fig.align="center"
)

```

```{r setup05, echo = FALSE}
#libraries

library(clusterProfiler)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(ChIPseeker)
library(genomation)
library(DESeq2)
library(ggbeeswarm)
library(ggpubr)
library(ggplot2)
library(magrittr)
library(gtable)
library(glmnet)
library(patchwork)
library(scales)
library(gridExtra)
library(ggrepel)
library(broom)
library(plyr)
library(dplyr)
library(tidyverse)
library(msigdbr)
library(png)
library(cowplot)
library(Hmisc)
library(MultiAssayExperiment)
library(biomartr)
library(biomaRt)
library(patchwork)

```

```{r loadData05, eval = TRUE}

#data("df", "patMeta", "LDT", "survT", "dds_smp")
#df_complete <- df

#Data
#df: tibble containing all screening viability data
load("data/df.RData")
df_complete <- df

#patMeta: tibble containing all patient genetic data
load("data/patMeta.RData")


#diffTF_large: tibble containing diffTF weighted mean difference values for 636 TFs, for trisomy 12 versus non-trisomy 12 CLL ATACseq data
load( "data/diffTF_large.RData")


#diffTF_small: tibble containing diffTF weighted mean difference values for 636 TFs, for trisomy 12 versus non-trisomy 12 CLL ATACseq data
load( "data/diffTF_small.RData")

#ChIPseq data for SPIB and PU1 binding in OCILY3 cell line (downloaded from GEO)
#get info on dataset of interest
chipSeq <- getGEOInfo(genome="hg19", simplify=FALSE) %>% dplyr::filter(series_id=="GSE56857")
#Define gsm id for SPIB and PU1 ChIPseq dataset in OCILY3 cell line (DLBCL)
gsm_spib = "GSM1370276"
gsm_pu1 = "GSM1370275"                                                         
#download bed file if not already there                                          
downloadGSMbedFiles(gsm_spib, destDir="data/")
downloadGSMbedFiles(gsm_pu1, destDir="data/")

#read the data
#ChIPseq data downloaded from GEO Accession Number: GSE56857
peak.spib <-  genomation ::readBed("data/GSM1370276_OCILY3_SPIB_GEM_events.bed.gz", track.line = "auto")
peak.pu1 <-  genomation ::readBed( "data/GSM1370275_OCILY3_PU1_GEM_events.bed.gz", track.line = "auto")


#SPIB_KD_Cellcounts: a tibble containing Normalized Cell Counts for Cell Lines infected with shRNA against SPIB and PU1 from Tina Becirovic
load( "data/SPIB_KD_Cellcounts.RData")


#Load proteomics data from Sophie Herbst
load("data/multiomics_MAE.RData")


#Full RNA dataset: Deseq2 object
load("data/dds_smp_full.RData")

#Matching samples only RNA dataset: Deseq2 object
load("data/dds_smp.RData")

#cytReceptors: tibble containing meta data on cytokine receptors
load( "data/cytReceptors.RData")

#cyt_and_receptors: tibble containing meta data on cytokines and receptors
load( "data/cyt_and_receptors.RData")


```

```{r themes_functions05, echo = FALSE, eval = TRUE}

### ggplot themes
fontsize = 11

## theme for ggplots
t1 <- 
  theme(                              
  plot.background = element_blank(), 
  panel.grid.major = element_line(),
  panel.grid.major.x = element_line(linetype = "dotted", colour = "grey"),
  panel.grid.minor = element_blank(), 
  panel.border = element_blank(), 
  panel.background = element_blank(),
  axis.line = element_line(size=.4),
  axis.line.x = element_line(),
  axis.line.y = element_line(),
  axis.text.x  = element_text(angle=90, size=11, hjust = 1, vjust = 0.4),
  axis.text.y = element_text(size = 11),
  axis.ticks.length = unit(0.3,"cm"),
  axis.title.x = element_text(face="bold", size=13), 
  axis.title.y = element_text(face="bold", size=13),
  plot.title = element_text(face="bold", size=14, hjust = 0.5),
  strip.text = element_text(size = fontsize)
)

t2 <- t1+
  theme( axis.text.x  = element_text(angle=0, size=11, hjust = 0.5, vjust = 1))

## theme for legends
t.leg <-  theme(legend.title = element_text(face='bold', 
                                            hjust = 1, size=11),
                legend.key = element_blank(),
                legend.text = element_text(size=11),
                legend.background = element_rect(color = "black"))



### Set colour palettes

#For Categorical: 
colors <- c("#A1BE1F", #green
            "#F4C61F", #yellow
            "#734595", #purple
            "#D41645", #red
            "#3B6FB6", #blue
            "#B65417", #orange
            "#E2E868", #light green
            "#CBA3D8", #light purple
            "#E58F9E", #light purple
            "#8BB8E8", #light blue
            "#F49E17", #light orange
            "#303030", #black
            "#A8A99E", #grey
            "#007B53") #dark green



#For Divergent: 
Divergent <- c("#003DA5", "#2055B0", "#406EBC", "#6086C7", "#809ED2", "#9FB6DD", "#BFCFE9", "#DFE7F4", "white", "white", "white","#F4E0E7", "#E9C2CF", "#DEA3B6", "#D3849E", "#C76586", "#BC476E", "#B12855", "#A6093D")

#for negatives only: 
palblues <- c("#003DA5", "#2055B0", "#406EBC", "#6086C7", "#809ED2", "#9FB6DD", "#BFCFE9", "#DFE7F4")

#for positives only:
palreds <- c("#F4E0E7", "#E9C2CF", "#DEA3B6", "#D3849E", "#C76586", "#BC476E", "#B12855", "#A6093D")

#For mutations: 
Mutant <- c("#b5b5b5","#373A36")
Sex <- c("#707372","#D0D0CE")
IGHV <- c("#373A36","#D0D0CE")
Methylation_cluster <- c("#373A36","#A8A99E","#D0D0CE")

#For drugs: 
drugpal <- c("#734595", "#CBA3D8") #purples

#For cytokines: 
cytpal <- c("#F49E17", "#EFC06E") #yellows


#neutral
offwhite <- "#f8f8ff"
lightergrey <- "#D0D0CE"
darkergrey <- "#707372"


na_color="#f0f0f0"


###FUNCTIONS
#select lasso or ridge 
runGlm05 <- function(X, y, method = "lasso", repeats=30, folds = 3) {
  
  #set up objects
  modelList <- list()
  lambdaList <- c()
  varExplain <- c()
  
  #set up a matrix for values of coefficients, with a row for each feature, and a column for each repeat
  coefMat <- matrix(NA, ncol(X), repeats)
  
  #make row names = genetic features
  rownames(coefMat) <- colnames(X)
  #set alpha according to selected method
  if (method == "lasso"){
    alpha = 1
  } else if (method == "ridge") {
    alpha = 0
  }
  
  #Run cv.glmnet for chosen number of repeats 
  for (i in seq(repeats)) {
    
    #if there are more than two features, fit a glm
    if (ncol(X) > 2) {
      
      res <- cv.glmnet(X,y, type.measure = "mse", family="gaussian", 
                       nfolds = folds, alpha = alpha, standardize = FALSE)
      
      #add lambda min from this repeat to the list of lambdas
      lambdaList <- c(lambdaList, res$lambda.min)
      
      #put the res object (with lambdas) into the list of models
      modelList[[i]] <- res
      
      #extract the coefficients for each feature, for lambda.min
      coefModel <- coef(res, s = "lambda.min")[-1] #remove intercept row
      
      #put these coefficients into  column of coefMatrix corresponding to the repeat
      coefMat[,i] <- coefModel
      
      #calculate variance explained
      y.pred <- predict(res, s = "lambda.min", newx = X)
      varExp <- cor(as.vector(y),as.vector(y.pred))^2
      varExplain[i] <- ifelse(is.na(varExp), 0, varExp) 
      
     
      
    } else {
      #if there are only two features, fit a linear model
      fitlm<-lm(y~., data.frame(X))
      varExp <- summary(fitlm)$r.squared
      varExplain <- c(varExplain, varExp)
      
    }
  }
  #gather all lists
  list(modelList = modelList, lambdaList = lambdaList, varExplain = varExplain, coefMat = coefMat)
}


makelegends <- function (legendFor, colors) {
    x = NULL
    y = NULL
    colors = colors[names(colors) %in% legendFor]
    nleg = length(colors)
    
    #set up gtable
    wdths = c(0.4,2,2,2,1.5)
    hghts = c(2)
    
    gtl = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    n = 2
    
    #legend for Methylation Cluster
    if ("M" %in% names(colors)) {
        Mgg = ggplot(data = data.frame(x = 1, 
                                       y = factor(c("LP", "IP", "HP"), 
                                                  levels = c("LP", "IP", "HP"))), 
                     aes(x = x, y = y, fill = y)) + 
              geom_tile() + 
              scale_fill_manual(name = "Methylation cluster", 
                                values = setNames(colors[["M"]], 
                                                  nm = c("LP", "IP","HP"))) + 
              theme(legend.title = element_text(size = 12), 
                    legend.text = element_text(size = 12))
        
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Mgg), "guide-box"), 1, n)
        n = n + 1
    }
    
    #Legend for IGHV status
    if ("I" %in% names(colors)) {
        Igg = ggplot(data = data.frame(x = 1, y = factor(c("Unmutated", 
            "Mutated"), levels = c("Unmutated", "Mutated"))), 
            aes(x = x, y = y, fill = y)) + geom_tile() + scale_fill_manual(name = "IGHV", 
            values = setNames(colors[["I"]], nm = c("Unmutated", "Mutated"))) + 
            theme(legend.title = element_text(size = 12), 
                  legend.text = element_text(size = 12))
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Igg), 
            "guide-box"), 1, n)
        n = n + 1
    }
    
    #legend for gene mutations
    if ("G" %in% names(colors)) {
        Ggg = ggplot(data = data.frame(x = 1, y = factor(c("Wild Type", 
            "Mutated"), levels = c("Wild Type", "Mutated"))), 
            aes(x = x, y = y, fill = y)) + geom_tile() + scale_fill_manual(name = "Gene", 
            values = setNames(colors[["G"]], nm = c("Wild Type", "Mutated"))) + 
            theme(legend.title = element_text(size = 12), 
                  legend.text = element_text(size = 12))
        gtl = gtable_add_grob(gtl, gtable_filter(ggplotGrob(Ggg), 
            "guide-box"), 1, n)
        n = n + 1
    }
    
    return(list(plot = gtl, width = sum(wdths), height = sum(hghts)))
}

lassoPlot05 <- function(lassoOut, geneMatrix, viabMatrix, freqCut = 1, coefCut = 0.01) {
  
  plotList <- list()
  
  for (seaName in names(lassoOut)) { 
    ###FOR THE BAR PLOT
    #extract coefMat for each stimulus
    barValue <- rowMeans(lassoOut[[seaName]]$coefMat)
    #extract proportion of repeats for which each coefficient is significant
    freqValue <- rowMeans(abs(sign(lassoOut[[seaName]]$coefMat)))
    #filter out coefficients that don't meet freqCut and coefCut thresholds
    barValue <- barValue[abs(barValue) >= coefCut & freqValue >= freqCut] 
    #arrange the bar values in numerical order
    barValue <- barValue[order(barValue)]
    #if there are no sig coefficients, don't plot
    if(length(barValue) == 0) {
      plotList[[seaName]] <- NA
      next
    }
    ###FOR THE HEATMAP AND SCATTER PLOT
    #get feature matrix and response matrix to plot
    allData <- geneMatrix
    viabValue <- unlist(viabMatrix[seaName,])
    
    #get feature matrix for sig coefficients only
    tabValue <- allData[, names(barValue),drop=FALSE]
    ord <- order(viabValue)
    viabValue <- viabValue[ord]
    tabValue <- tabValue[ord, ,drop=FALSE]
    sampleIDs <- rownames(tabValue)
    tabValue <- as_tibble(tabValue)
    tabValue$Sample <- sampleIDs
    
    
    #annotate mutations by mutation, methylation or IGHV
    matValue <- gather(tabValue, key = "Var",value = "Value", -Sample)
    matValue$Type <- "mut"
    
    #for Methylation Cluster
    matValue$Type[grep("Methylation",matValue$Var)] <- "meth"
    
    #for IGHV status
    matValue$Type[grep("IGHV",matValue$Var)] <- "ighv"
    
    #change the scale of the value so that IGHV, Methylation and Mutation do not overlap
    matValue[matValue$Type == "mut",]$Value = matValue[matValue$Type == "mut",]$Value + 10
    matValue[matValue$Type == "meth",]$Value = matValue[matValue$Type == "meth",]$Value + 20
    matValue[matValue$Type == "ighv",]$Value = matValue[matValue$Type == "ighv",]$Value + 30
    
    #change continuous to categorical
    matValue$Value <- factor(matValue$Value,levels = sort(unique(matValue$Value)))
    
    #arrange order of heatmap
    matValue$Var <- factor(matValue$Var, levels = names(barValue))
    matValue$Sample <- factor(matValue$Sample, levels = names(viabValue))
    
    #change labels if mutation is a Doehner mutation 
    matValue$Var <- revalue(matValue$Var, c("del11q" = "del(11q)", "del13q" = "del(13q)", "del17p" = "del(17p)", "trisomy12" = "trisomy 12")) 
    
   
     #plot the heatmap 
      #title
    if(seaName=="TGF-b1"){
      thetitle <- "TGF-\u03B21"     
      } else {
        if(seaName=='IL-4'){ 
          thetitle <- "IL4"  
          } else {
            thetitle <- seaName
          }
        }
    
      p1 <- ggplot(matValue, aes(x=Sample, y=Var)) + 
            geom_tile(aes(fill=Value), color = "white") + #ghost white
            theme_bw()+
            scale_y_discrete(expand=c(0,0)) + 
            theme(axis.title.y = element_text( size=14),
                  axis.title.x = element_text( size=14),
                  axis.text.x=element_text(hjust=0, size=11),
                  axis.text.y=element_text(hjust=0.1, size=11),
                  axis.ticks=element_blank(),
                  panel.border=element_rect(colour="gainsboro"),  
                  plot.title=element_text(face="bold", size = 18, margin = margin(t = -5, b = 1)), 
                  panel.background=element_blank(),
                  panel.grid.major=element_blank(), 
                  panel.grid.minor=element_blank()) + 
            xlab("Mutation status for each patient") + 
            ylab("") + 
            scale_fill_manual(name="Mutated", 
                              values=c(`10`= offwhite,  #WT
                                       `11`="#373A36", #Mutant
                                       `20`= offwhite, #LP
                                       `20.5`= "#707372", #IP
                                       `21` = "#A8A99E", #HP
                                       `30` = offwhite, #IGHV-U
                                       `31` = "#707372"), #IGHV-M
                                       guide="none") + 
            ggtitle(thetitle)
        
         
    #Plot the bar plot on the left of the heatmap 
    barDF = data.frame(barValue, nm=factor(names(barValue),levels=names(barValue)))
    
    p2 <- ggplot(data=barDF, aes(x=nm, y=barValue)) + 
      geom_bar(stat="identity", 
               fill=ifelse(barValue<0,
                           palblues[6],palreds[8]), 
               colour="black", 
               size=0.3) + 
      scale_x_discrete(expand=c(0,0.5)) + 
      scale_y_continuous(expand=c(0,0)) + 
      coord_flip(ylim=c(-0.3,0.35)) + #changed from min(barValue) and max(barValue)
      theme(panel.grid.major=element_blank(), 
            panel.background=element_blank(), 
            axis.ticks.y = element_blank(),
            panel.grid.minor = element_blank(), 
            axis.text=element_text(size=11, angle = 45, hjust = 1, vjust = 1),
                axis.title = element_text(size=14), 
            panel.border=element_blank()) +
      ylab("Size of predictor") + 
      geom_vline(xintercept=c(0.5), 
                 color="black", 
                 size=0.6)
    
    #Plot the scatter plot under the heatmap
    scatterDF = data.frame(X=factor(names(viabValue), 
                                    levels=names(viabValue)), 
                           Y=unlist(viabValue))
    
    p3 <- 
      ggplot(scatterDF, aes(x=X, y=Y)) + 
      geom_point(shape=21, 
                     fill="dimgrey", 
                     colour="#707372", #dark grey
                     size=1.2) + 
      theme_bw() +
      theme(panel.grid.minor=element_blank(), 
                panel.grid.major.x=element_blank(), 
                #axis.title.x=element_blank(), 
                axis.ticks.x=element_blank(), 
                axis.text.y=element_text(size=11), 
                axis.title.x=element_text(size=14), 
                panel.border=element_rect(colour="dimgrey", size=0.1),
                panel.background=element_rect(fill="white")) +
      xlab("Log(Viability) for each sample")
    
    
    #Assemble all the plots togehter
    # construct the gtable
    wdths = c(0.2, 1.5, 0.2, 1.3*ncol(matValue), 1.5, 0.2)
    hghts = c(0.2, 0.2, 0.0020*nrow(matValue), 0.3, 1, 0.2)
    gt = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    
    ## make grobs
    gg1 = ggplotGrob(p1)
    gg2 = ggplotGrob(p2)
    gg3 = ggplotGrob(p3)
    ## fill in the gtable
   
    #HEATMAP
    #5:1 = "PREDICTORS"
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) # add heatmap
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) #add legend
    gt = gtable_add_grob(gt, gtable_filter(gg1, "title"), 1, 4) #add title to plot
    gt = gtable_add_grob(gt, gtable_filter(gg1, "axis-l"), 3, 5) # variable names
    gt = gtable_add_grob(gt, gtable_filter(gg1, "xlab-b"), 2, 4) # axis title
    
    #BARPLOT
    gt = gtable_add_grob(gt, gtable_filter(gg2, "panel"), 3, 2) # add barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-b"), 4, 2) # y axis for barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "xlab-b"), 2, 2) # y lab for barplot
    
    #SCATTER PLOT
    gt = gtable_add_grob(gt, gtable_filter(gg3, "panel"), 5, 4) # add scatterplot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "xlab-b"), 6, 4) # x label for scatter plot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "axis-l"), 5, 3) #  axis for scatter plot
    
   
    
    #plot
    #grid.draw(gt)
    plotList[[seaName]] <- gt
  }
  return(plotList)
  
  
  
}



########### Scaling and Centering of Viability Matrix ################

# medianCenter_MadScale: 
#function to  scale with MAD, center to merdian
medianCenter_MadScale05 <- function(x) {
  s <- median(x)
  #s=0
  (x - s) / mad(x, center = s)
}

# scaleCytResp function:  to apply medianCenter_MadScale row wise to viability matrix
scaleCytResp05  <- function(x) t(apply(x, 1, medianCenter_MadScale05)) 

#ROC cruve

#function to plot ROC curves
plotROC05 <- function(glmModel, X, y, lambda = "lambda.1se") {
  lambdaChose <- glmModel[[lambda]]
  glmPred <- prediction(predict(glmModel, type = "response", newx = X, s=lambdaChose), y)
  glmPerform <- performance(glmPred,"tpr","fpr")
  aucVal <- performance(glmPred, measure = "auc")@y.values[[1]]
  xname <- glmPerform@x.name
  yname <- glmPerform@y.name
  plotTab <- tibble(x= glmPerform@x.values[[1]],
                    y = glmPerform@y.values[[1]])
  p <- ggplot(plotTab, aes(x=x, y =y )) + geom_line(color = "red") +
    xlab(xname) + ylab(yname) + theme(panel.grid = element_blank())
  
  if (!is.null(aucVal)) {
    p <- p + annotate("text", x= 0.75, y = 0.25, label = sprintf("AUC: %1.2f", aucVal))
  }
  list(plot=p, auc = aucVal)
}

#indicate how to split test set and training set
testPartition05 <- function(y, ratio) {
  #balanced sampling of test set
  ord <- seq_along(y)
  testIdx <- lapply(unique(y),function(n) {
    subY <- ord[y == n]
    sample(subY, size = as.integer(length(subY)  * ratio)) 
  }) %>% do.call(c,.) %>% sort()
  return(testIdx)
}

#Function for multi-variant binomial regression
runGlm.bin <- function(X, y, method = "lasso", repeats=20, folds = 3, testRatio = NULL, lambda = "lambda.1se") {
  modelList <- list()
  lambdaList <- c()
  aucCV <- c()
  aucTest <- c()
  rocTest <- list()
  coefMat  <- matrix(NA, ncol(X), repeats)
  rownames(coefMat) <- colnames(X)
  
  if (method == "lasso"){
    alpha = 1
  } else if (method == "ridge") {
    alpha = 0
  }
  
  for (i in seq(repeats)) {
    if (!is.null(testRatio)) {
      testIdx <- testPartition(y, testRatio)
      X.test <- X[testIdx,]
      X.train <- X[-testIdx,]
      y.test <- y[testIdx]
      y.train <- y[-testIdx]
    } else {
      X.train <- X
      y.train <- y
    }
    
    #need to add a set seed for this function, but ensure that it changes with each loop otherwise all 10 repeats are the same 
    vecFold <- mltools::folds(y.train, nfolds = folds, stratified = TRUE, seed = i)
    
    #train model
    res <- cv.glmnet(X.train,y.train, type.measure = "auc",
                      foldid = vecFold, alpha = alpha, standardize = FALSE,
                     intercept = TRUE, family = "binomial")
    lambdaList <- c(lambdaList, res[[lambda]])
    #If you arent splitting the data into a training and testing dataset. you can use the AUC for the CV
    aucCV <- c(aucCV, res$cvm[res$lambda == res[[lambda]]])
    modelList[[i]] <- res
    coefMat[,i] <- coef(res, s = lambda)[-1]
    
    #test model if testRatio is speficied- can use this AUC to identify the best model 
    if(!is.null(testRatio)) {
      rocRes <- plotROC(res, X.test, y.test, lambda)
      aucTest <- c(aucTest, rocRes$auc)
      rocTest[[i]] <- rocRes$plot
    }
  }
  list(modelList = modelList, lambdaList = lambdaList, aucCV = aucCV, coefMat = coefMat,
       aucTest = aucTest, rocTest = rocTest)
}

#function to visualise predictors of Trisomy 12 status
lassoPlot_bin <- function(lassoOut, xIn, yIn, freqCut = 1, coefCut = 0.01, symbolMap = NULL, modelIndex = NULL, textWidth =0.8, rowHeight = 0.0005) {
  
    #for the barplot on the left of the heatmap
    if (is.null(modelIndex)) {
      #average all models
      barValue <- rowMeans(lassoOut$coefMat)
      freqValue <- rowMeans(lassoOut$coefMat !=0)
      barValue <- barValue[abs(barValue) > coefCut & freqValue >= freqCut] # a certain threshold
      barValue <- barValue[order(barValue)]
      if(length(barValue) == 0) {
        return(NA)
      }
    } else {
      #using a specificed model
      barValue <- lassoOut$coefMat[,modelIndex]
      barValue <- barValue[abs(barValue) > coefCut] # a certain threshold
      barValue <- barValue[order(barValue)]
      if(length(barValue) == 0) {
        return(NA)
      }
    }
    
    #for the heatmap and scatter plot below the heatmap
    mapData <- xIn
    scatterData <- yIn
    
    ord <- order(scatterData)
    scatterData <- scatterData[ord]
    mapData <- mapData[ord, names(barValue) ,drop=FALSE]
    idOrd <- rownames(mapData) #to record the order of the rows
    mapData <- mapData %>% as_tibble() %>% mutate(row = idOrd) %>%
      gather(key = "Var", value = "Value", -row) %>%
      mutate(row = factor(row, levels = idOrd),
             Var = factor(Var, levels = names(barValue)))
    #add tri12 status
    tri12meta <- dplyr::select(patMeta, PatientID, trisomy12) 
    tri12meta$PatientID <- as.factor(tri12meta$PatientID)
    colnames(mapData) <- c("PatientID", "Var", "Value")
    mapData_tri12 <- left_join(mapData, tri12meta, by =  "PatientID")
    
    #update labeling 
    mapData_tri12$Var <- revalue(mapData_tri12$Var, c("Resiquimod" = "Resiquimod", "TGF-b1" = "TGF-\u03B21", "sCD40L+IL-4" = "sCD40L + IL4")) 
    
    #plot the heatmap
    p1 <- ggplot(mapData_tri12, aes(x=PatientID, y=Var)) + geom_tile(aes(fill=Value),color = "gray") + 
      theme_bw()  + 
      theme(axis.text.x=element_blank(), axis.ticks=element_blank(), 
            panel.border=element_rect(colour="gainsboro"),  
            plot.title=element_text(size=18), 
            panel.background=element_blank(), 
            panel.grid.major=element_blank(), 
            panel.grid.minor=element_blank()) + 
      xlab("Samples") + ylab("Log(Viability)") + 
      ggtitle("")+
      scale_fill_gradient2(low = palblues[1],high = palreds[8], mid = "white",guide="none")+ 
      facet_grid(~trisomy12, space = "free", scales = "free") + theme(strip.background =element_rect(fill="white"))
    
    #Plot the bar plot on the left of the heatmap
    if (is.null(symbolMap)) {
      barDF = data.frame(barValue=barValue, 
                         nm=factor(names(barValue),levels=names(barValue)))
    } else {
      #a id to symbol dataframe is provided
      barDF = data.frame(barValue = barValue, 
                         nm = symbolMap[names(barValue),1])
      barDF$nm <- factor(barDF$nm, levels = unique(barDF$nm))
    }
    
    p2 <- ggplot(data=barDF, aes(x=nm, y=barValue)) + 
      geom_bar(stat="identity", fill=darkergrey, colour="black", position = "identity", width=.66, size=0.2) + 
      theme_bw() + geom_hline(yintercept=0, size=0.3) + scale_x_discrete(expand=c(0,0.5)) + 
      scale_y_continuous(expand=c(0,0)) + 
      coord_flip(ylim=c(min(barValue),max(barValue))) + 
      theme(panel.grid.major=element_blank(), 
            panel.background=element_blank(), axis.ticks.y = element_blank(),
            panel.grid.minor = element_blank(), axis.text.y=element_text(size=8, hjust=0),
            axis.text.x = element_text(size=10),
            panel.border=element_blank()) +
      xlab("") + 
      ylab("Size of predictor") + 
      geom_vline(xintercept=c(0.5), color="black", size=0.6)
    

    #Scale bar for continuous variable

    Vgg = ggplot(mapData, aes(x=PatientID, y=Var, col = Value)) + 
      geom_point() + 
      scale_color_gradient2(low = palblues[1],high = palreds[8], mid = "white", name = "z-score") + 
      theme(legend.title=element_text(size=10), legend.text=element_text(size=10))
    
    #Assemble all the plots together

    # construct the gtable
    
    wdths = c(1.5, 0.2, 1.3*ncol(mapData), textWidth,0.8)
    hghts = c(0.2, rowHeight*nrow(mapData), 0.2, 0.5)
    gt = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    
    ## make grobs
    gg1 = ggplotGrob(p1)
    gg2 = ggplotGrob(p2)
    gg4 = ggplotGrob(Vgg)
    
    ## fill in the gtable
    gt = gtable_add_grob(gt, gtable_filter(gg2, "panel"), 2, 1) # add barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "xlab-b"), 1, 1) # add  y axis label to barplot 
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 2, 3) # add heatmap
    gt = gtable_add_grob(gt, gtable_filter(gg1, "strip-t"), 1, 3) # add facetstip to plot
   
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-b"), 3, 1) # y axis for barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-l"), 2, 4) # variable names
    gt = gtable_add_grob(gt, gtable_filter(gg4, "guide-box"), 2, 5) # scale bar for continous variables

    
    #plot
    #grid.draw(gt)
    gt
}

```


```{r processData05, echo = FALSE}
#REMOVE
#Subset data to Cytokine only treatments, no drugs 
#Remake dataframe, then can load with this premade in future

df <- dplyr::filter(df, Drug == "DMSO", Cytokine != "No Cytokine") %>% 
  dplyr::mutate(Cytokine = as.character(Cytokine)) %>%
  dplyr::mutate(Cytlabel = ifelse(Cytokine == "IL-2", "IL2",
                            ifelse(Cytokine == "IL-4", "IL4",
                                   ifelse(Cytokine == "IL-6", "IL6", 
                                          ifelse(Cytokine == "IL-10", "IL10",
                                                 ifelse(Cytokine == "IL-10", "IL10",
                                                        ifelse(Cytokine == "IL-21", "IL21",
                                                               ifelse(Cytokine == "sCD40L+IL-4","sCD40L + IL4",
                                                                      ifelse(Cytokine == "IL-15", "IL15",
                                                                             ifelse(Cytokine == "Interferon gamma","Interferon \u03B3",
                                                                                    ifelse(Cytokine == "SDF-1a","SDF-1\u03B1",
                                                                                           ifelse(Cytokine == "IL-1b","IL-1\u03B2",
                                                                                                  ifelse(Cytokine == "TGF-b1","TGF\u03B2", Cytokine))))))))))))) %>%
  
  dplyr::mutate(Cytokine = factor(Cytokine))


df_complete <- df_complete %>%
  dplyr::mutate(Cytokine = as.character(Cytokine)) %>%
  dplyr::mutate(Cytlabel = ifelse(Cytokine == "IL-2", "IL2",
                            ifelse(Cytokine == "IL-4", "IL4",
                                   ifelse(Cytokine == "IL-6", "IL6", 
                                          ifelse(Cytokine == "IL-10", "IL10",
                                                 ifelse(Cytokine == "IL-10", "IL10",
                                                        ifelse(Cytokine == "IL-21", "IL21",
                                                               ifelse(Cytokine == "sCD40L+IL-4","sCD40L + IL4",
                                                                      ifelse(Cytokine == "IL-15", "IL15",
                                                                             ifelse(Cytokine == "Interferon gamma","Interferon \u03B3",
                                                                                    ifelse(Cytokine == "SDF-1a","SDF-1\u03B1",
                                                                                           ifelse(Cytokine == "IL-1b","IL-1\u03B2",
                                                                                                  ifelse(Cytokine == "TGF-b1","TGF\u03B2", Cytokine))))))))))))) %>%
  
  dplyr::mutate(Cytokine = factor(Cytokine))

#patMeta
patMeta$treatment <- as.factor(patMeta$treatment)

#Lists of Cytokines
thecytokines <- unique(df$Cytokine) %>% setdiff("No Cytokine")


```

## Systematic analysis of the effect of genetic features on responses to stimuli
### Univariate analysis identifies IGHV status and trisomy 12 as key modulators of microenvironmental response
To begin, I ran a univariate analysis to compare viability values post-stimulation for patient samples with and without each genetic feature. In total 63 genetic features were surveyed, including IGHV status, somatic gene mutations and structural variants, where there were at least three patient samples in each group (Figure \@ref(fig:stimuliGeneAssosciations)). 


(ref:stimuliGeneAssosciations) Plot showing BH-adjusted p values from Student's t-tests (two-sided, with equal variance), for all tested gene-stimulus associations. Tests performed for IGHV status and somatic mutations and copy number aberrations with â‰¥3 patient samples in each group (n = 63). Each circle represents a gene-stimulus association. Associations that meet 10% FDR cut off are indicated in colour, where the colour denotes the genetic feature. 

```{r stimuliGeneAssosciations, fig.cap='(ref:stimuliGeneAssosciations)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '70%', dev = 'cairo_pdf'}

##################### List of mutations with >2 postive cases #############################
selected_mutations <- 
  patMeta %>% 
  mutate(Ras_Raf = as.factor(ifelse(BRAF == 1 | KRAS == 1| NRAS == 1, 1, 0))) %>% 
  dplyr::select(-BRAF, -KRAS, -NRAS) %>% 
  dplyr::select( -gender, 
                 -diagnosis, 
                 ) %>%
  pivot_longer(-PatientID, 
               names_to = "Genetic_Alteration", 
               values_to = "alteration_value") %>% 
  dplyr::filter(alteration_value %in% c(1, "U")) %>% 
  dplyr::group_by(Genetic_Alteration) %>% 
  dplyr::count() %>% 
  dplyr::filter(n>2) %>% 
  dplyr::select(Genetic_Alteration) %>% 
  unlist()

##################### t tests and p-value adjustment ###############################  
p_values <-
  ## Select columns from screening data 
  dplyr::select(df, PatientID, Log, Cytokine) %>% 
  
  ## Join Screening data with metadata
  left_join(patMeta, by = "PatientID") %>%
  
  ## Add Ras/Raf column, remove single columns
  mutate(Ras_Raf=as.factor(ifelse(BRAF == 1 | KRAS == 1 | NRAS == 1, 1, 0))) %>% 
  dplyr::select(-BRAF, -KRAS, -NRAS) %>% 
## remove unused columns from metadata
  dplyr::select( -gender, 
                 -diagnosis, 
                 -treatment) %>% 
  
  ## transform data to long format
  pivot_longer(cols=c(-PatientID, -Log, -Cytokine), 
               names_to = "Genetic_alt", 
               values_to = "alt_value") %>% 
  
  ## filter to selected mutations (see above)
  dplyr::filter(Genetic_alt %in% selected_mutations) %>% 
  
  
  ## group by Cytokine and Genetic alteration  
  dplyr::group_by(Cytokine, Genetic_alt) %>% 
  
  ## Perform t.test on every combination of Cytokine and genetic alteration
  do(tidy(t.test(Log ~ alt_value, data = ., var.equal = T))) %>% 
  
  ## ungroup before adjusting p-value
  ungroup() %>% 
  
  ## adjust p-values to multiple testing using BH method 
  mutate(adj.p.value=p.adjust(p.value, method = "BH"))
  
################################## Order of cytokines by descending significance ############################
Cytokine_order <-
  p_values %>% 
  dplyr::group_by(Cytokine) %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::filter(row_number() == 1) %>% 
  ungroup() %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::select(Cytokine) %>% 
  unlist()

Genetic_alt_order <-
  p_values %>% 
  dplyr::group_by(Genetic_alt) %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::filter(row_number() == 1) %>% 
  ungroup() %>% 
  dplyr::arrange(adj.p.value) %>% 
  dplyr::select(Genetic_alt) %>% 
  unlist()

############################# Define FDR cutoff #################################
fdr = 0.1
  
############################################ Plot ########################################
p_values %<>% 
  mutate(Cytokine=factor(Cytokine, levels = Cytokine_order)) %>% 
  mutate(Genetic_alt=factor(Genetic_alt, levels = Genetic_alt_order))
  
  ggplot(dplyr::filter(p_values, adj.p.value>fdr), 
         aes(x = Cytokine, y = -log10(adj.p.value))) +
  geom_point(color = "lightgrey", size = 3) +
  geom_beeswarm(data = dplyr::filter(p_values, adj.p.value <= fdr), 
                aes( color=Genetic_alt), size = 3, cex = 1.7) +
  ##FDR line  
  geom_hline(yintercept = -log10(fdr),linetype = "dashed", size=0.3)+
  
  ##Main Theme
  t1 +
  
  theme(axis.text.x = element_text(angle = 45,
                                   hjust = 1, 
                                   vjust = 1),
        axis.title.x=element_blank()) +
  ##Legend Theme
  theme(legend.position=c(0.65,0.65), 
        legend.title = element_text(face='bold', hjust = 0, size=13), 
        legend.key = element_blank(),  
        legend.text = element_text(size=11)) +
  guides(colour = guide_legend(nrow=7, title = "Mutations"), 
         shape = guide_legend(ncol = 1)) +
  scale_color_manual(name = "Mutations", values = colors, labels=c("IGHV.status"="IGHV status", 
                                                                   "del9p"="del(9p)", 
                                                                   "trisomy12"="trisomy 12", 
                                                                   "gain17q"="gain(17q)", 
                                                                   "gain2p"="gain(2p)",
                                                                   "gain19p"="gain(19p)",
                                                                   "gain19q"="gain(19q)",
                                                                   "del7q"="del(7q)",
                                                                   "del9q"="del(9q)", 
                                                                   "del4p"= "del(4p)", 
                                                                   "SPEN"="SPEN", 
                                                                   "del11q"="del(11q)", 
                                                                   "del1q" = "del(1q)")) +
  scale_y_continuous(expression("BH-adjusted  "* italic(p)*"-value"), 
                     breaks=seq(0, 10, 5),
                     labels=math_format(expr=10^.x)(-seq(0,10,5))) +
  
  scale_x_discrete(labels = c("TGF-b1"="TGF-\u03B21", "sCD40L+IL-4"="sCD40L + IL4", "IL-1b"="IL1\u03B2", "IL-4"="IL4", "IL-6"="IL6","IL-15"="IL15","IL-10"="IL10", "IL-21"="IL21","IL-2"="IL2", "Interferon gamma"= "Interferon \u03B3", "SDF-1a"="SDF-1\u03B1"))



```

This analysis revealed the extent to which genetic features modulate microenvironmental response: for ten out of 17 stimuli, at least one genetic feature determined  response and for six out of 17 stimuli, two or more genetic features significantly altered the response (Student's  t-tests,  FDR  =  10%). The most common features were IGHV status and trisomy 12. Del(11q) also affected response to several stimuli. Notably,  del(13q) and del(17p), which are some of the most common aberations in CLL and also act as prognostic markers [@Dohner2000] had no impact on the responses to the panel of stimuli. 

### Heterogenetiy of response is not caused by differences in receptor expression
Next, we tested whether the observed heterogeneity of response was caused by differences in receptor expression.  We calculated Pearson correlation coefficients comparing control - normalised  log viability values for each stimulus with transformed RNA counts of the corresponding stimulus receptor(s). No  stimulus-receptor pair showed a correlation greater than 0.4, confirming that the heterogeneity of response was not caused by differential receptor expression. 

(ref:RNAcorrelations) Volcano plot showing p-values versus Pearson correlation coefficients, for the correlation between control - normalised log viability values for each stimulus and expression of the corresponding stimulus receptor, in matched patient samples. Expression calculated using transformed RNA counts (using VST method) of untreated CLL sample.

```{r RNAcorrelations, fig.cap='(ref:RNAcorrelations)', message = FALSE,  echo = FALSE, fig.height=10, fig.width=7, fig.align="center", out.width = '70%', dev = 'cairo_pdf'}


#VST
vsd <- vst(dds_smp, blind=TRUE)

#rename transformed counts
assayNames(vsd)<-"transformedcounts"
ColData<-as.data.frame(colData(dds_smp))
tidy_RNA_data<-
  vsd%>%
  tidy()%>%
  filter(gene%in%cytReceptors$ENSEMBLID)%>%
  dplyr::rename(PatientID=sample)%>%
  left_join(cyt_and_receptors, by=c("gene"="ENSEMBLID"))

RNA_Screen_data <-
  df %>%
  filter(Drug=="DMSO", Cytokine%in%c("Resiquimod","IL-4" ,"TGF-b1","IL-1b",
                                     "Interferon gamma","SDF-1a","sCD40L",
                                     "sCD40L+IL-4","soluble anti-IgM","CpG ODN",
                                     "IL-6","IL-10","IL-21","anti-IgM Beads",
                                     "HS-5 CM","IL-15","BAFF","IL-2")) %>%
  filter(PatientID %in% unique(tidy_RNA_data$PatientID)) %>%
  select(PatientID, Cytokine, Normalized) %>%
  left_join(tidy_RNA_data, by=c("PatientID", "Cytokine"))
Cytokine_Receptor_combinations <-
  RNA_Screen_data %>%
  group_by(Cytokine, Receptor)%>%
  summarize(.groups = "keep") %>%
  filter(!is.na(Receptor))

Cytokine_Receptor_combinations$p.value<-as.numeric(NA)
Cytokine_Receptor_combinations$pearson_R<-as.numeric(NA)

for(i in 1:nrow(Cytokine_Receptor_combinations)) {
  x=Cytokine_Receptor_combinations[i,]
  Correlation_data_matrix<-RNA_Screen_data%>%
    mutate(Cytokine_Receptor=paste0(Cytokine,":", Receptor))%>%
    filter(Cytokine_Receptor==paste0(x[1],":",x[2]))%>%
    select(Normalized, value)%>%
    as.matrix()
  correlation_res<-cor.test(Correlation_data_matrix[,1],Correlation_data_matrix[,2], method = "pearson")
  Cytokine_Receptor_combinations[which(Cytokine_Receptor_combinations$Cytokine==unlist(x[1])&Cytokine_Receptor_combinations$Receptor==unlist(x[2])),]$p.value=correlation_res$p.value
  Cytokine_Receptor_combinations[which(Cytokine_Receptor_combinations$Cytokine==unlist(x[1])&Cytokine_Receptor_combinations$Receptor==unlist(x[2])),]$pearson_R<-correlation_res$estimate
}
Cytokine_Receptor_combinations <- Cytokine_Receptor_combinations%>%
  mutate(adj.p.value=p.adjust(p.value, method="fdr"))
colnames(Cytokine_labels) <- c("Cytokine", "Cytlabel")
Cytokine_Receptor_combinations <- left_join(Cytokine_Receptor_combinations, Cytokine_labels, by = "Cytokine")
Cytokine_Receptor_combinations$Receptor[grepl("IL-10 R alpha",Cytokine_Receptor_combinations$Receptor)]<-"IL10 R \u03B1"
Cytokine_Receptor_combinations$Receptor[grepl("IL-10 R beta",Cytokine_Receptor_combinations$Receptor)]<-"IL10 R \u03B2"
Cytokine_Receptor_combinations$Receptor[grepl("IL-15 R alpha",Cytokine_Receptor_combinations$Receptor)]<-"IL15 R \u03B1"
Cytokine_Receptor_combinations$Receptor[grepl("IL-2 R beta",Cytokine_Receptor_combinations$Receptor)]<-"IL2 R \u03B2"
Cytokine_Receptor_combinations$Receptor[grepl("IL-2 R gamma",Cytokine_Receptor_combinations$Receptor)]<-"IL2 R \u03B3"
 
Cytokine_Receptor_combinations$Receptor[grepl("IL-1 R1",Cytokine_Receptor_combinations$Receptor)]<-"IL1 R1"
Cytokine_Receptor_combinations$Receptor[grepl("IL-2 R alpha",Cytokine_Receptor_combinations$Receptor)]<-"IL2 R \u03B1"
Cytokine_Receptor_combinations$Receptor[grepl("IL-13 R A1",Cytokine_Receptor_combinations$Receptor)]<-"IL13 R A1"
Cytokine_Receptor_combinations$Receptor[grepl("IFN-gamma R2",Cytokine_Receptor_combinations$Receptor)]<-"IFN \u03B3 R2"
Cytokine_Receptor_combinations$Receptor[grepl("IL-6 R",Cytokine_Receptor_combinations$Receptor)]<-"IL6 R"
Cytokine_Receptor_combinations$Receptor[grepl("IFN gamma R1",Cytokine_Receptor_combinations$Receptor)]<-"IFN \u03B3 R1"
Cytokine_Receptor_combinations$Receptor[grepl("IL-4 R alpha",Cytokine_Receptor_combinations$Receptor)]<-"IL4 R \u03B1"
CR_volcanoplot <-
  ggplot(Cytokine_Receptor_combinations,
         aes(x=pearson_R,
             y=-log10(adj.p.value)))+
  geom_point(data=filter(Cytokine_Receptor_combinations, pearson_R>(-0.3)&pearson_R<0.3), color="grey")+
  geom_point(data=filter(Cytokine_Receptor_combinations, pearson_R<(-0.3)|pearson_R>0.3), color="red")+
   geom_label_repel(data=filter(Cytokine_Receptor_combinations, pearson_R<(-0.3)|pearson_R>0.3), nudge_x = 0.07, color="red", aes(label=paste0(Cytlabel, " | ", Receptor)), size=5)+
  geom_label_repel(data=filter(Cytokine_Receptor_combinations, pearson_R<(-0.1)|pearson_R>0.1, !(pearson_R<(-0.3)|pearson_R>0.3)), nudge_x = 0.07, color="grey", aes(label=paste0(Cytlabel, " | ", Receptor)), size=5)+
  coord_cartesian(xlim=c(-0.45,0.45))+
  geom_vline(xintercept = -0.3, linetype=3)+
  geom_vline(xintercept = 0.3, linetype=3)+
  theme_minimal()+
  scale_x_continuous(breaks = c(-0.3,0,0.3))+
  xlab("Pearson Correlation Coefficient")+
  ylab("-log10(BH adjusted p-value)")+
  t2
CR_volcanoplot
```

### Multivariate analysis of gene - stimulus assosciations confirms IGHV status and trisomy 12 as key modulators of stimulus response
It was possible that there may be interplay between genetic factors in determining responses to external signals. To address this, I applied multivariate modelling to integrate the influence of genetic features, IGHV status and DNA methylation on the size of response. I used a Gaussian linear model with L1-penalty (i.e., lasso regression),  to derive a predictor for each stimulus, comprised of these covariates. 

As input to the model, the response matrix was composed of the log transformed viability values for each stimulus. To generate the feature matrix (137 samples versus 39 features), I excluded genetic features for which >20\% of the values were missing, and  patient samples with incomplete annotation. As predictors, I included genetic mutations and CNVs (p= 39), IGHV status (coded as 0-1) and Methylation Cluster (coded as 0, 0.5, 1). I ran lasso regression, as implemented in the `R` package `glmnet`[@R-glmnet], using three-fold cross-validation with misclassification error as loss. The resulting predictors are the mean of those coefficients that were selected in at least 75% of 30 bootstrapped repeats. 

Using the output of the regression, I generated predictor profiles for each stimulus. For 5 / 17 stimuli, there was at least one genetic predictor that met the cut-offs (a selection are shown in figure \@ref(fig:stimuliGeneAssosciationsMulti)).

(ref:stimuliGeneAssosciationsMulti) Predictor profiles for IL4, CpG ODN and TGF$\beta$ depicting gene - stimulus associations determined using Gaussian linear modelling with L1-penalty. Bar plots (left) show size and sign of assigned coefficients named on the right. A positive coefficient indicates that when stimulated with given cytokine, the increase in viability is larger when the feature is present. Scatter plots (bottom) and corresponding heatmaps above show how the presence of selected genetic feature relate to the sample viabilities. Scatter plots show ranked log(viability) values for each sample and heatmaps show mutation status for each of the genetic predictors for corresponding sample in scatter plot. 

```{r stimuliGeneAssosciationsMulti, fig.cap='(ref:stimuliGeneAssosciationsMulti)', message = FALSE,  echo = FALSE, fig.height=9, fig.width=8.5, fig.align="center", out.width = '70%', dev = 'cairo_pdf'}

#Generate feature Matrix
#select features from patient meta file
geneMatrix <- 
  dplyr::select(patMeta,
                -c(gender:treatment)) %>%
  
  #adjust IGHV.status levels  U and M to numeric 1 and 0 
  mutate(IGHV = ifelse(is.na(IGHV.status), NA,
                       ifelse(IGHV.status == "M", 1, 0)), 
         #adjust Methylation_Cluster levels  LP, IP, HP to 0, 0.5, 1
         Methylation = ifelse(is.na(Methylation_Cluster), NA,
                              ifelse(Methylation_Cluster == "LP", 0,
                                     ifelse(Methylation_Cluster == "IP", 0.5, 1))),
         #remove old columns
         IGHV.status=NULL, Methylation_Cluster=NULL ) %>%

  
  #convert factors to numeric
  mutate_if(is.factor, as.character) %>%
  mutate_at(vars(-PatientID), as.numeric) %>%
  
  #convert to matrix format, with patient IDs as rownames
  data.frame() %>% 
  column_to_rownames("PatientID") %>% 
  as.matrix()
#Tidy matrix for use in glmnet function
#Remove genes with higher than 20% missing values
geneMatrix <- geneMatrix[,colSums(is.na(geneMatrix))/nrow(geneMatrix) <= 0.2]
#Filter for patients with complete data
geneMatrix.complete <- geneMatrix[complete.cases(geneMatrix),]
#Combine KRAS, NRAS and BRAF mutations into a single column
#set up empty matrix
Ras_Raf <- matrix(NA, 
                  nrow = nrow(geneMatrix.complete), 
                  ncol = 1)
colnames(Ras_Raf) <- "RAS/RAF"
#add RAS/RAF column to matrix
geneMatrix.complete <- cbind(geneMatrix.complete, Ras_Raf)
#Annotate RAS_RAF where where any of KRAS, NRAS or BRAF are mutated
geneMatrix.complete[,"RAS/RAF"] <- ifelse(geneMatrix.complete[,"KRAS"]==1,1,
		                                        ifelse(geneMatrix.complete[,"BRAF"]==1,1,
	                	                          ifelse(geneMatrix.complete[,"NRAS"]==1, 1, 0)))
#remove KRAS, NRAS and BRAF columns
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "KRAS"]
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "BRAF"]
geneMatrix.complete <- 
  geneMatrix.complete[, colnames(geneMatrix.complete) != "NRAS"]


# Set up viability response matrix
viabMatrix <- 
  #select patients with complete meta data 
  dplyr::filter(df,
                PatientID %in% row.names(geneMatrix.complete)) %>%
  #select cytokine, patient and log(viability values only)
  dplyr::select(Cytokine, 
                Log, 
                PatientID) %>% 
  #reshape data
  spread(key = PatientID, value = Log) %>% 
  data.frame() %>% 
  #make Cytokine the row names
  remove_rownames() %>%
  column_to_rownames("Cytokine")
#make sample order same as in geneMatrix
viabMatrix <- viabMatrix[,rownames(geneMatrix.complete)]


#Run lasso regression
#set object to hold model outputs
dataResult <- list()
#fit model for each stimulus
for (i in rownames(viabMatrix)){  
  
    #prepare input and response matrices
    y <- unlist(viabMatrix[i,]) # viability for each patient with given condition
    X <- geneMatrix.complete #genetic features for each patient
    #fit the model
    cvglmfit <- runGlm05(X, y, method="lasso", repeats=30, folds=3)
    
    #collect the results for each stimulus in one object
    dataResult[[i]] <- cvglmfit
}


#Get predictor profiles for stimuli of interest

heatMaps_cyt <- lassoPlot05(dataResult[c("IL-4","CpG ODN", "TGF-b1")] , 
                          geneMatrix.complete, #use gene matrix for heatmap 
                          viabMatrix, #use viab matrix for scatter plot
                          freqCut = 0.75, #coefficients should be selected in <75% of bootstrapped model files
                          coefCut = 0.00) #no minimum value for coefficients 


#Assemble legend for heatmaps
#G# = gene mutations, I = IGHV, M = Methylation Cluster
legendFor = c("G", "I", "M")

#assign colours for I, G and M
coldef<-list()
coldef["I"] <- list(c(offwhite,"#707372")) #U-CLL and M-CLL
coldef["M"] <- list(c(offwhite, "#707372", "#A8A99E")) #IP, HP, LP
coldef["G"] <- list(c(offwhite, "#373A36")) #WT and Mutated
legends = makelegends(legendFor=c("G","I","M"),coldef)

#assemble
Fig3B_1 <- invisible(wrap_elements(arrangeGrob( grobs = heatMaps_cyt[1], ncol =1)))
Fig3B_2 <- invisible(wrap_elements(arrangeGrob( grobs = heatMaps_cyt[2], ncol =1)))
Fig3B_3 <- invisible(wrap_elements(arrangeGrob( grobs = heatMaps_cyt[3], ncol =1)))
Fig3B_leg <- legends[["plot"]] %>% wrap_elements()



blankplot <- 
  ggplot() +
  geom_blank() +
  theme(panel.background = element_blank())

wrap_elements(Fig3B_1 + Fig3B_2 + Fig3B_3 +
                wrap_elements(blankplot + Fig3B_leg + 
                                plot_layout(ncol=2, widths  = c(0.15,0.9))) +
                plot_layout(ncol=1, heights = c(1.7,1.7,1.7,0.5)))



```

The multivariate analysis demonstrated that responses to IL4 and sCD40L + IL4, TLR and TGF$\beta$ were all affected by multiple genetic features. 

For example, presence of trisomy 12 or IGHV-U was associated with a stronger increase in viability upon stimulation by IL4. In contrast, samples with a mutation in KRAS, NRAS or BRAF showed a smaller increase in viability upon stimulation, in other words, these tumours benefited less from the anti-apoptotic effects of IL4. This could indicate that the ability of IL4 to increase the viability of the samples is in part dependent upon signalling via RAS/RAF, which is already active in mutant samples. 

The response to TLR stimulation by CpG ODN showed the largest number of predictors, reflecting the multiple layers of biology involved. These included del(11q) and *ATM* , del(17p) and *TP53*, IGHV status, trisomy 12 and *SF3B1*. In general,  TGF$\beta$ activation led to a decrease in viability in CLL samples, and this was enahnced in IGHV-U and trisomy 12 samples. 

Summarise systematic anlaysis , in the rest of this chapter, we look at indiviudal findings 
UPDATE THIS: 

Two concepts emerged from this analysis. Firstly, the number of predictors for the response to TLR stimulation by CpG ODN indicates the multiple layers of biology involved. TLR response was highly heterogenous and a determinant of cluster membership that also related to clinical disease progress. For this reason, I decided to investigate these in more detail.

This analysis also highlighted trisomy 12 and IGHV status as the most common features to modulate responses to stimulation. IGHV status relates to the mutational status of the BCR, and so it is expected that the activity of the BCR signalling pathway may affect responses to other cytokine pathways (Figure \@ref(fig:IHGVBCR)). In contrast, whilst trisomy 12 is frequently occurs in CLL patients, its role in CLL drive is still incompletely understood. These results suggest a role in responding to microenvironmental signals, so I decided to investigate this in more detail.

(ref:IHGVBCR) Control-normalised log transformed viabilty values after treatment with sCD40L, IL1$\beta$ and TGF$\beta$, stratified by IGHV status. 

```{r IHGVBCR, fig.cap='(ref:IHGVBCR)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8, fig.align = "center", out.width = '100%', dev = 'cairo_pdf'}


#add genetic data to viability dataframe
df_patmeta <- left_join(df, patMeta, by = "PatientID")

gg = 
  lapply(c("sCD40L", "IL-1\u03B2","TGF\u03B2"), function(x){

df_patmeta %>% 
  dplyr::filter(Cytlabel==x,
                !is.na(IGHV.status)) %>%

         
  ggplot(aes(x=IGHV.status,y=Log,color=(IGHV.status)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("IGHV status") +
  ylab("Log(Viability)") +
  ggtitle(x) +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

})

wrap_elements(gg[[1]]) + wrap_elements(gg[[2]]) + wrap_elements(gg[[3]]) 


```

## Investigating the genetic determinants of TLR response
The responses to TLR stimulation by CpG ODN and Resiquimod were both determined by many genetic features, including del(11q) and *ATM* , del(17p) and *TP53*, IGHV status, trisomy 12 and *SF3B1* (Figure \@ref(fig:TLRGenes)). 

(ref:TLRGenes) Control-normalised log transformed viabilty values after treatment with Resqiumod (TLR 7/8), stratified by named genetic features. 

```{r TLRGenes, fig.cap='(ref:TLRGenes)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 10,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


ATM <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(ATM)) %>%
         
  ggplot(aes(x=ATM,y=Log,color=(ATM)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("ATM") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

del11q <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(del11q)) %>%
         
  ggplot(aes(x=del11q,y=Log,color=(del11q)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("del(11q)") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

SF3B1 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(SF3B1)) %>%
         
  ggplot(aes(x=SF3B1,y=Log,color=(SF3B1)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("SF3B1") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

trisomy12 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(trisomy12)) %>%
         
  ggplot(aes(x=trisomy12,y=Log,color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("trisomy 12") +
  ylab("Log(Viability)") +
  ggtitle("Resiquimod") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

del17p <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(del17p)) %>%
         
  ggplot(aes(x = del17p,y = Log,color = (del17p)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("del(17p)") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

TP53 <- 
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod") %>%
      filter(!is.na(TP53)) %>%
         
  ggplot(aes(x=TP53,y=Log,color=(TP53)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("TP53") +
  ylab("Log(Viability)") +
  ggtitle("") +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2



(del11q + trisomy12 + del17p)/
(ATM + SF3B1 + TP53)  

```

MAybe edit this down, move to discussion
IGHV status is  known to affect response to TLR stimulation [@Chatzouli2014], leading to increased viability in IGHV-U samples, and decreased in IGHV-M. @Chatzouli2014 show that stimulation of TLR in IGHV-U samples leads to pronounced p-ERK induction, whereas in M-CLL, stimulation of TLR concomitantly with BCR stimulation is required to induce a smaller increase in p-ERK. TLR stimulation without BCR stimulation in IGHV-M samples leads to an induction of caspase-8 and apoptosis, much more so than in IGHV-U samples[@Chatzouli2014].

We noted trisomy 12 as an additional, previously unknown, determinant of TLR response (Bruch & Giles et al. 2021). In samples that do not have trisomy 12, as expected TLR stimulation increases the viability of IGHV-U samples, whilst it decreases viability in IGHV-M samples. In contrast, in samples with trisomy 12, TLR stimulation increases viability regardless of IGHV status (Studentâ€™s t-test, p<0.001 and p=0.018, Figure \@ref(fig:TLRIHGVtri12)).

The Chatzouli paper points to the existence of specific types of BCR/TLR collaboration  in CLL, dependent on the mutational status of the BCR. Our results point to a role for trisomy12 12 in this collaboration between TLR and BCR signalling.


(ref:TLRIHGVtri12) Beeswarm-boxplot showing control-normalised log transformed viability values, after treatment with Resiquimod, stratified by trisomy 12 and IGHV status. p-values from Studentâ€™s t-tests. 

```{r TLRIHGVtri12, fig.cap='(ref:TLRIHGVtri12)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


#filter for Resiquimod-only treatment, only show patients who are annoyated for IGHV and Trisomy12
df_patmeta %>% 
  dplyr::filter(Cytokine=="Resiquimod",
                !is.na(trisomy12),
                !is.na(IGHV.status)) %>%
         
  ggplot(aes(x=interaction(IGHV.status, trisomy12),
                    y=Log,
                    color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  scale_x_discrete(labels=c("M.0"="IGHV-M\n WT",
                            "U.0"="IGHV-U\n WT",
                            "M.1"="IGHV-M\n trisomy 12",
                            "U.1"="IGHV-U\n trisomy 12"))+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     comparisons = list( c(1,2), c(3,4), c(1,3)),
                     size=3)+
  xlab("") +
  ylab("Log(Viability)") +
  ggtitle("Resiquimod") +
  scale_color_manual(values=c(colors[1], colors[2])) + 
  coord_cartesian(ylim = c(-1.5, 3.1), clip="off") +
  t1+
  theme(axis.text.x = element_text(angle = 45, vjust =1))


```
The impact of del(11q), del(17p), and *ATM* and *TP53* mutations on TLR response is also interesting. Del(17p) occurs in 7% of CLL cases and is associated with loss of TP53, a tumour suppressor gene involved in DNA damage and repair [@Zenz2010]. del(11q) is more common (18% of cases) and is associated with loss of ATM, another protein involved in DNA repair[@Kipps2017]. This suggests that there may be a role for the DNA damage response in determining whether CLL viability is increased or decreased in the presence of TLR stimulation. 

Activation of TLR 7/8/9 was one of the most potent modulators of CLL viabilty identified in the screen. The impact of TLR stimulation is also highly variable and dependet on many genetic features. The role of TLR signalling in CLL pathogenesis and prognosis may so far be underappreciated. 

## Investigating Trisomy 12 as a modulator of microenvironmental response
### Trisomy 12 modulates responses to IL4, TGF$\beta$ and TLR stimuli
Our survey of genetic determinants of stimuli response highlighted trisomy 12 as a modulator of responses to IL4, TGF$\beta$, soluble CD40L + IL4 and TLR stimuli (Bruch & Giles et al. 2021, Figure \@ref(fig:tri12cytResponse)). For example, the increase in viability induced by IL4 was enhanced in trisomy 12 samples, as was the decrease in viability in response to TGF$\beta$ stimulation. 

Trisomy 12 is commonly found in CLL (15% of patients)[@Dohner2000]. Until recently, this genetic lesion has been regarded as endowing?? intermediate risk, though novel therapies have improved outcomes for trisomy 12 patients [@Bosch2019]. However, the functional explanation for its recurrence remains undetermined. In the following, I outline my work to investigate how trisomy 12 may act as a modulator of responses to environmental signals in CLL.

(ref:tri12cytResponse) Control-normalised log transformed viability values after treatment with IL4, sCD40L + IL4 and TGF$\beta$, stratified by trisomy 12. 

```{r tri12cytResponse, fig.cap='(ref:tri12cytResponse)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

#add genetic data to viability dataframe
df_patmeta <- left_join(df, patMeta, by = "PatientID")

ii = 
  lapply(c("IL4", "sCD40L + IL4", "TGF\u03B2"), function(x){

df_patmeta %>% 
  dplyr::filter(Cytlabel==x,
                !is.na(trisomy12)) %>%

         
  ggplot(aes(x=trisomy12,y=Log,color=(trisomy12)))+
  geom_hline(yintercept = 0)+
  geom_boxplot()+
  geom_beeswarm(cex=1.5) +
  guides(color="none", shape="none")+
  stat_compare_means(method = "t.test",
                     label.x.npc = "center", 
                     size=3)+
  xlab("trisomy 12") +
  ylab("Log(Viability)") +
  ggtitle(x) +
  scale_color_manual(values=c(colors[1], colors[2])) + 

  t2

})

wrap_elements(ii[[1]]) + wrap_elements(ii[[2]]) + wrap_elements(ii[[3]]) 

```

### Gene dosage effects {#gene-dosage-effects}
Trisomy 12 samples contain a third copy of chromosome 12: transcriptomic and proteomic profiling of CLL samples with this lesion have demonstrated that this has a major impact on gene expression and protein abundances [@Abruzzo2018; @HerbstThesis; @MeierAbt2021]. It has also been shown that BCR signalling proteins are amongst those with increased expression in trisomy 12 [@HerbstThesis], and this is thought to contribute to increased susceptibility to BCR inhibition in trisomy 12 CLL [@JCI]. 

Guided by this observation, I began by investigating RNA and protein expression levels amongst genes involved in the TGF$\beta$, IL4 and TLR pathways, to which trisomy 12 samples respond more strongly. The aim was to determine whether proteins in these pathways are more abundant in trisomy 12 CLL, thus contributing to the enhanced response.  

I ran differential expression analysis to compare CLL samples from the screen with and without trisomy 12. Next, I filtered the differentially expressed genes (adjusted p < 0.1) for those belonging to the TGF$\beta$, JAK-STAT and TLR pathways genesets, from the KEGG database. I visualised the RNA counts and protein abundances for those genes. 

Only a small proportion of the differentially expressed genes belonged to the TGF$\beta$, JAK-STAT and TLR pathways genesets. However of those that were, several genes were key downstream mediators of these pathways (Figure \@ref(fig:geneDosage). Amongst TGF$\beta$ signalling genes, 7 / 95 were upregulated in trisomy 12, including SMAD3. 12 / 160 IL4 signalling genes were differentially expressed, 3 of those are found on chromosome 12, including STAT2 and STAT6. Only 2 / 116 genes in the TLR geneset were differentially expressed, though significantly this included IRAK4 on chromosome 12. Amongst these key mediators, SMAD3, STAT2 and STAT6, and IRAK4, all showed higher protein abundance in addition to RNA expression. 

(Figure \@ref(fig:geneDosage).

(ref:geneDosage) Beeswarm-boxplots showing RNA counts and protein abundances for named genes, stratified by trisomy 12 status. P values from Student's t-test. _The Proteomics dataset was kindly shared by Sophie Herbst, generated as part of her doctoral thesis [@HerbstThesis]..._ 
**COMBINE FIGURES**

```{r prepgeneDosage}

#get table to convert between IDS
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", version="90")
transAnno <- getBM(attributes=c('ensembl_gene_id','hgnc_symbol','chromosome_name', 'transcript_biotype'), mart = ensembl)
transAnno <- dplyr::filter(transAnno, hgnc_symbol != "")
id2gene <- dplyr::select(transAnno, ensembl_gene_id, hgnc_symbol)

```

```{r SMAD3geneDosage, fig.cap='(ref:SMAD3geneDosage)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

data <- plotCounts(dds_smp, gene="ENSG00000166949", #SMAD3
                   intgroup=c("trisomy12"), 
                   returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))


#Make plot
SMAD3rna <- 
  ggplot(data, aes(x = trisomy12, y = count, color=trisomy12)) +
  geom_boxplot() +
  geom_beeswarm() + 
  ggtitle("SMAD3") +
  ylab("Counts") +
  xlab("Trisomy 12 Status") +
  t2 +
  scale_color_manual(values = c(colors[1], colors[2])) +
  theme(aspect.ratio=1,  legend.position = "none") +
  stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
 
    
df_tbl_prot <- 
  wideFormat(multiomics_MAE["SMAD3",,"proteomics"] ) %>% as_tibble()

colnames(df_tbl_prot)[2] <- "protein"

mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]

df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
colnames(df_tbl_SNP)[2] <- "alteration"
df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" )

#Make plot
SMAD3pro = 
  df_tbl %>% 
  filter(!is.na(alteration), !is.na(protein)) %>% 
  
  ggplot(aes(alteration, protein, colour = alteration, group=alteration)) +
  scale_y_log10() +
  geom_boxplot() + 
  geom_point() +
  ggtitle("SMAD3") +
  ylab("Protein abundance") +
  xlab("trisomy 12") + 
  theme_bw() +  
  scale_colour_manual(values = c(colors[1],colors[2])) + 
  t2 + 
  theme(aspect.ratio=1,  legend.position = "none") +
  stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
  
     
SMAD3rna + SMAD3pro

```

(Figure \@ref(fig:STATgeneDosage)).

(ref:STATgeneDosage) 
```{r STATgeneDosage, fig.cap='(ref:STATgeneDosage)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


stat_rna <- 
lapply(c("ENSG00000166888", "ENSG00000170581"), function(x){
    #Prep data for plot
    data <- plotCounts(dds_smp, gene=x, intgroup=c("trisomy12"), returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
    
    #get hgnc symbol from ENS id
    gene_name <-
    as.data.frame(rowData(dds_smp)) %>% 
    rownames_to_column("ensembl_gene_id") %>%
    filter(ensembl_gene_id == x) %>%
    dplyr::select(symbol)
    if(gene_name== "SPI1"){genename <- "PU.1"}
    
    #Make plot
    ggplot(data, aes(x = trisomy12, y = count, color=trisomy12)) +
      geom_boxplot() +
      geom_beeswarm() + 
      ggtitle(gene_name) +
      ylab("Counts") +
      xlab("") +
      
      t2 +
      scale_color_manual(values = c(colors[1], colors[2])) +
      theme(aspect.ratio=1,  legend.position = "none") +
      
      stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
  
})


stat_pro = lapply(c("STAT6", "STAT2"), function(x){
     #Prepare data for plot
     df_tbl_prot <- wideFormat(multiomics_MAE[x,,"proteomics"] ) %>% as_tibble()
     colnames(df_tbl_prot)[2] <- "protein"
     
     mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]
     df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
     colnames(df_tbl_SNP)[2] <- "alteration"
     df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
     
     df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" )
     
     #Make plot
      gg = df_tbl %>% filter(!is.na(alteration), !is.na(protein)) %>% ggplot(aes(alteration, protein, colour = alteration, group=alteration)) +
       geom_boxplot() + 
       geom_point() +
        
       ggtitle("")+
       ylab("Protein abundance") +
       xlab("trisomy 12") + 
        
       theme_bw()+  
       scale_colour_manual(values = c(colors[1],colors[2])) + 
       t2 +  
       theme(aspect.ratio=1, legend.position = "none") +
       stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
  
})

(stat_rna[[1]] + stat_rna[[2]])/
  (stat_pro[[1]] + stat_pro[[2]]) 

```

(Figure \@ref(fig:IRAK4geneDosage)).

(ref:IRAK4geneDosage) 

```{r IRAK4geneDosage, fig.cap='(ref:IRAK4geneDosage)', message = FALSE,  echo = FALSE, fig.height = 5, fig.width = 8,  fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

#IRAK4

irak4_rna <- 
lapply(c("ENSG00000198001","ENSG00000172936"),  function(x){
    #Prep data for plot
    data <- plotCounts(dds_smp, gene=x, intgroup=c("trisomy12"), returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1"))
    
    #get hgnc symbol from ENS id
    gene_name <-
    as.data.frame(rowData(dds_smp)) %>% 
    rownames_to_column("ensembl_gene_id") %>%
    filter(ensembl_gene_id == x) %>%
    dplyr::select(symbol)
    if(gene_name== "SPI1"){genename <- "PU.1"}
    
    #Make plot
    ggplot(data, aes(x = trisomy12, y = count, color=trisomy12)) +
      geom_boxplot() +
      geom_beeswarm() + 
      ggtitle(gene_name) +
      ylab("Counts") +
      xlab("") +
      
      t2 +
      scale_color_manual(values = c(colors[1], colors[2])) +
      theme(aspect.ratio=1,  legend.position = "none") +
      
      stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3)
  
})


irak4_pro = lapply(c("IRAK4", "MYD88"), function(x){
     #Prepare data for plot
     df_tbl_prot <- wideFormat(multiomics_MAE[x,,"proteomics"] ) %>% as_tibble()
     colnames(df_tbl_prot)[2] <- "protein"
     
     mae_mini <- multiomics_MAE[,,c("SNPs", "chrom_abber", "health_record_bin")]
     df_tbl_SNP <- wideFormat(mae_mini["trisomy12",,]) %>% as_tibble()
     colnames(df_tbl_SNP)[2] <- "alteration"
     df_tbl_SNP <- df_tbl_SNP %>% mutate(alteration=factor(alteration))
     
     df_tbl <- left_join(df_tbl_prot, df_tbl_SNP, by="primary" )
     
     #Make plot
      gg = df_tbl %>% filter(!is.na(alteration), !is.na(protein)) %>% ggplot(aes(alteration, protein, colour = alteration, group=alteration)) +
       geom_boxplot() + 
       geom_point() +
        
       ggtitle("")+
       ylab("Protein abundance") +
       xlab("trisomy 12") + 
        
       theme_bw()+  
       scale_colour_manual(values = c(colors[1],colors[2])) + 
       t2 +  
       theme(aspect.ratio=1, legend.position = "none") +
       stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size=3) 
  
})

(irak4_rna[[1]] + irak4_rna[[2]])/
  (irak4_pro[[1]] + irak4_pro[[2]])

```
Next I looked for further evidence that the higher gene dosage may explain the trisomy 12 phenotype. 
### Classification analysis identifies trisomy 12 phenocopies that shed light on trisomy 12 mechansism
I next looked at whether any non-trisomy 12 samples showed a similar phenotype to the trisomy 12 samples, with stronger responses to the stimuli. The aim was to identify trisomy 12 phenocopies, in order to investigate the molecular profiles of these samples and isolate any features which may be repsoieble for enhanced responses . In particualr, I was interested to see if these phenocopies showed higher expression, or even gene amplification, of the genes identified above. 

To identifier trisomy 12 phenocopies, I generated a classifier which could predict trisomy 12 status of a sample from the response values to the panel of stimuli. I aimed to find non-trisomy 12 samples that were consistently misclassified as trisomy 12, indicating that their response profiles were similar to that of trisomy 12 samples. 

The classifier was built using binomial regression, with lasso penalisation,  as implemented in the `R` package `glmnet` [@R-glmnet]. The feature matrix consisted of z scores of the viability values after treatment with each stimulus, and was used to predict the response (trisomy 12 status). I ran the model for 50 bootstrapped repeats, using  three-fold cross-validation and mean absolute error as loss. Resiquimod, sCD40L+IL4 and TGF$\beta$ were selected as coefficients that predict trisomy 12 status (Figure \@ref(fig:tri12Classfier).


(ref:tri12Classfier) Predictor profile showing coefficients selected as predictors of trisomy 12 status. Here, binomial modelling with L1-penalty was used to identify associations between responses to stimuli and trisomy 12 status. Bar plots (left) show size and sign of assigned coefficients named on the right. A positive coefficient indicates that higher viability upon treatment named stimulus is associated with trisomy 12. Facet labels (top) and corresponding heatmap below show how the viability with each named stimulus relates to trisomy 12 status. The model shown was selected from 50 bootstrapped repeats, based on maximal AUC.

```{R phenocopyPrework}
########### Viability matrix ################
#make viability matrix for cytokine treatments for patients
cyt_viab <- dplyr::select(df, 
                PatientID, 
                Log, 
                Cytokine) %>% spread(Cytokine, Log) %>% as.data.frame()

#make PatID the row names
rownames(cyt_viab) <- unlist(cyt_viab[,1]) # the first row will be the header
cyt_viab <- dplyr::select(cyt_viab,-PatientID) 

cyt_viab <- t(cyt_viab)

#run scaleCytResp on viability matrix
x <- scaleCytResp05(cyt_viab)
x <-t(x)


## Response matrix 
#Get Tri 12 status
y <- dplyr::select(patMeta, PatientID, trisomy12) %>% dplyr::filter(!is.na(trisomy12)) %>% column_to_rownames("PatientID")

y$trisomy12 <- as.numeric(as.character(y$trisomy12))

y <- t(y)

#Remove NA patients from viability matrix
x <- x[colnames(y),]


# Run logistic regression
X <- x

#set whether to spilt data into test and training set
testRatio = FALSE

#set parameters for running model
repeats <- 50
folds <- 3

if(testRatio){
  
  glmRes <- runGlm.bin(X,as.integer(y), repeats = repeats, folds =folds, testRatio = 0.3)
  
}else{
  
  glmRes <- runGlm.bin(X, as.integer(y), repeats = repeats, folds = folds, testRatio = NULL)}



## ROC of best model
if(testRatio){
iBest <- which.max(glmRes$aucCV)
glmRes$rocTest[[iBest]]
}else{
  iBest <- which.max(glmRes$aucCV)
}

```



```{r tri12Classfier, fig.cap='(ref:tri12Classfier)', message = FALSE,  echo = FALSE, fig.height=3, fig.width = 8, fig.align="center", out.width = '100%', dev = 'cairo_pdf'}

X.scale <- X

p <- lassoPlot_bin(glmRes, X.scale, y,freqCut = 0, coefCut = 0.01, modelIndex = iBest, rowHeight = 0.001)

grid.arrange(p)

```

I then ran the classifier on the same dataset, using the viabilty z scores to predict trisomy 12 status, using each of the 50 bootstrapped models. I compared the results of the classification with the true trisomy 12 status. Two patient samples were consistently misclassified as trisomy 12 in more than 50% of repeats, here I refer to them as patient sample A and B. 

To investigate these samples in more detail, I first looked at their responses to the stimuli of interest (Figure \@ref(fig:tri12PhenocopiesCytResponse). Patient sample A showed the lowest viability with TGF$\beta$. Patient sample B showed the highest viability with IL4, and the second highest with Resiquimod.  This appeared to be the cause of their missclassfication. 

(ref:tri12PhenocopiesCytResponse) Control-normalised log-transformed viability values, for all samples after treatment with Resiquimod, sCD40L + IL4 and TGF$\beta$. Patient sample A and B are indicated in blue and red, respectively. 

```{r tri12PhenocopiesCytResponse, fig.cap='(ref:tri12PhenocopiesCytResponse)', message = FALSE,  echo = FALSE, fig.height=3, fig.width = 3, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}


plotTab <- filter(df, Cytokine%in% c("Resiquimod", "sCD40L+IL-4", "TGF-b1"))
plotTab %>%
  ggplot(aes(x=Cytokine,
             y=Log)) + 
  geom_boxplot(fill=NA)+
  geom_beeswarm(cex=0.3, alpha=0.4, color= lightergrey)+
  t2 +
  ylab("Log(Viability") + xlab("")+
  geom_point(data=dplyr::filter(plotTab, PatientID =="Pat_033"), aes(x=Cytokine, y=Log), colour=palblues[1], size=2) + 
    geom_point(data=dplyr::filter(plotTab, PatientID =="Pat_114"), aes(x=Cytokine, y=Log), colour=palreds[8], size=2)+ scale_x_discrete(labels = c("Resiquimod" = "Resiquimod", "sCD40L+IL-4" = "sCD40L \n+ IL4", "TGF-b1" = "TGF-\u03B21"))


```
Next, to see whether the enhanced response of patient samples A and B were due to differences in gene dosage, I visualised the RNA expression levels for the proteins identified in \@ref(gene-dosage-effects). Patient sample A, which responded most strongly to Resiquimod, showed higher levels of IRAK4. PAtient sample B, which responded strongly to TGF$\beta$ showed the highest level of SMAD3 expression amongst the non-trisomy 12 samples. Neither sample showed any notable difference in STAT6 levels. 

(Figure \@ref(fig:tri12PhenocopiesRNA).

(ref:tri12PhenocopiesRNA) RNA counts for SMAD3, IRAK4 and STAT6, stratified by trisomy 12 status. Patient sample A and B are indicated in blue and red, respectively. P values from Student's t-test. 

```{r tri12PhenocopiesRNA, fig.cap='(ref:tri12PhenocopiesRNA)', message = FALSE,  echo = FALSE, fig.height=6, fig.width = 5, fig.align="center", out.width = '80%', dev = 'cairo_pdf'}
genes <- c(
           "ENSG00000166888", #STAT6
           "ENSG00000198001", #IRAK4
           "ENSG00000166949" #SMAD3
           )
RNAplots <- 
lapply(genes, function(x){
  data <- plotCounts(dds_smp_full, gene=x, intgroup=c("trisomy12"), returnData=TRUE) %>%
      filter(trisomy12 %in% c("0", "1")) %>% rownames_to_column("PatientID")
    
    #get hgnc symbol from ENS id
    gene_name <-
    as.data.frame(rowData(dds_smp_full)) %>% 
    rownames_to_column("ensembl_gene_id") %>%
    filter(ensembl_gene_id == x) %>%
    dplyr::select(symbol)
    
    #Make plot
    ggplot(data, aes(x = trisomy12, y = count, color = trisomy12)) +
      geom_boxplot() +
      geom_beeswarm() + 
      ggtitle(gene_name) +
      ylab("Counts") +
      xlab("trisomy 12") +
      
      t1 +
      scale_color_manual(values = c(colors[1], colors[2])) +
      theme(aspect.ratio=1,  text = element_text(size = 15), legend.position = "none") +
      
      stat_compare_means(method = "t.test", comparisons = list(c("1", "0")), size = 3) + 
      
      geom_point(data=dplyr::filter(data, PatientID =="Pat_114"), aes(x=trisomy12, y=count), colour=palreds[8], size=2) +
      geom_point(data=dplyr::filter(data, PatientID =="Pat_033"), aes(x=trisomy12, y=count), colour=palblues[1], size=2)
      
})

RNAplots[[1]] + RNAplots[[2]] + RNAplots[[3]] 


```
Finally, I aimed to check whether these two trisomy 12 phenocopies may have an amplicon on chromosome 12, which may help to isolate the gene or genes responsible for the trisomy 12 phenocopy, and by ...,  the genes that may drive the increased incidence of trisomy 12 in CLL. Whole exome sequencing was available for both patient samples A and B, and I used this data to check for differences in copy numbers on any regions of chromosome 12. Patient sample A had amplified regions at 12p13.31 (42 copies), 12q24.13 (10 copies) and 12q24.33  (21 copies).  None of these regiosn contained any of the signalling genes identified in  \@ref(gene-dosage-effects). 

These results collectively suggest that increased gene dosage of key genes in the IL4, TLR and TGF$\beta$ pathways may underlie the increased response of trisomy 12 samples to these pathways. This is also reflected in the patient samples A and B, which responded more strongly to the TGF$\beta$ and TLR pathways, respectively, and correspondingly higher levels of SMAD3 and STAT6 proteins. However, bioinformatics techniques can only go to far in providing biological proof. In the next stage of the analysis, I identified two more proteins that were of interest, and we decided to pursue this instead. 

###  Spi-B and PU.1 TFs show higher activity in trisomy12+ CLL
Trisomy 12 has been well-studied at the transcriptomic and proteomic level, and yet the cause of its recurrence in CLL  remains to be fully understood. My analysis of gene dosage and trisomy 12 phenocopies proved inconclusive. Thus, I next decided to investigate the impact of trisomy 12 on the epigenetic landscape of CLL, which is less well studied. In particular, I wanted to investigate differential transcription factor activity in CLL, which would give an indicator of which pathways are differentially active. 

I acquired two independent ATAC sequencing datasets. The first, planned by myself and P.M.B, and performed by P.M.B and N.A.Z, consisted of two WT and two trisomy 12 samples. The second, taken from @Rendeiro2017, comprised 43 WT and nine trisomy 12 samples. In the external dataset, trisomy 12 status was not annotated. To do this, we used the ATACseq reads to call trisomy 12 in samples that contained > 1.4 times more reads per peak (i.e. genomic region) on average in chromosome 12, compared to peaks on other chromosomes. 

(Figure \@ref(fig:tri12annotation).

(ref:tri12annotation) 

```{r tri12annotation, fig.cap='(ref:tri12annotation)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}


#ADd represemtative examples? 

```

Next, we used the `R` package `diffTF` [@R-diffTF] to identify TFs that showed differential binding site accessibility between the WT and trisomy 12 samples (Figure \@ref(fig:diffTFexplainer). To run diffTF, we provided a list of 636 TFs, and the genomic locations of their bindings sites, taken from the HOCOMOCO v10 database [@HOCOMOCO]. For each TF, the diffTF software uses the ATACseq counts at each of the binding sites accross the genome to generate a distribution of fold changes between trisomy 12 and WT samples. This fold change distribution is compared to a background distribution of fold changes, calculated similarly using ATACseq counts for a GC-matched motif, that does not contain the TF binding motif. The TF is classified as differentially active between trisomy 12 and WT samples where these two distributions are significantly different. Each TF is assigned a weighted mean difference value, which quantifies the change in activity, and a p value. 

(ref:diffTFexplainer) 

```{r diffTFexplainer, fig.cap='(ref:diffTFexplainer)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

knitr::include_graphics("figures/diffTF_method.eps")

```

Running this analysis on both ATACseq datasets indicated that the binding sites of nine TFs  were more accessible (p<0.05) in the trisomy 12 samples of the larger, external dataset (Figure \@ref(fig:tri12diffTF). In the smaller in-house dataset, the binding sites of 92 TFs were likewise more accessible (Supp. Figure \@ref(fig:diffTFsmallvolPlot)). RNA and proteomics data show different abundances of transcripts and proteins in trisomy 12 CLL: ATACseq data here shows that this also corresponds to a specific signalling signature in trisomy 12 CLL. 

We confirmed that the results were not affected by the additional copy of chromosome 12, by replicating the diffTF analysis without the ATACreads from chromsome 12. This did not impact on the signficant TFs.  

In both datasets, the TFs with the largest increase in activity in trisomy 12  were Spi-B and/or PU.1. Both TFs share similar binding motifs and exhibit functional redundancy[@GarrettSinha2001], which make it difficult to distinguish from ATACseq data whether either or both are more active. 

Spi-B and PU.1  are haematopoetic regulators that are known to be key regulators of healthy B-cell function [@Turkistany2011][READ MORE], controlling B-cell responses to environmental cues including CD40L, TLR ligands and IL4 [@Willis2017].

(ref:tri12diffTF) Bar plot showing the results of the diffTF analysis for the @Rendeiro2016 dataset. y axis shows change in TF activity (weighted mean difference)  between trisomy 12 (n = 9) and non-trisomy 12 samples (n = 43),x axis indicates TF names. 17 / 636 TFs, with BH adjusted p <0.05 are shown. p values generated by diffTF in permutation mode. TF binding sites defined in HOCOMOCO v10 [@HOCOMOCO].

```{r tri12diffTF, fig.cap='(ref:tri12diffTF)', message = FALSE,  echo = FALSE,fig.height=6, fig.width=8, fig.align="center", out.width = '80%', dev = 'cairo_pdf'}


#Get all TFs that show differential activity
plotTab.diffTF <- dplyr::filter(diffTF_large, pvalueAdj < 0.05)
#change to name of TF quoted in text
plotTab.diffTF$TF <- gsub("SPI1", "PU1", plotTab.diffTF$TF)
#order by weighted mean difference
idx <- order(plotTab.diffTF[["weighted_meanDifference"]], decreasing = TRUE)
plotTab.diffTF$TF <- factor(plotTab.diffTF$TF,levels=rev(unique(plotTab.diffTF$TF[idx])))
#plot figure

  ggplot(plotTab.diffTF,
         aes(x=weighted_meanDifference,
             y=TF,
             fill= ifelse(weighted_meanDifference>0, 
                          palreds[5], palblues[1]))) +
  geom_bar(stat = "identity", width = 0.75) +
  xlim(c(-0.2, 0.175)) +
  
  #colours and theme
  scale_fill_manual(values = c(palblues[1], palreds[8]), guide = "none") +
  t1 + 
  theme(axis.text.x = element_text(angle = 45, vjust =1))+
  
  #Labels
  ylab("") + 
  xlab("Change in TF activity") +
  ggtitle("Diffential TF activity in trisomy 12 CLL") + 
  
  #Add annotations
  #arrow 1
  annotate("segment", x = -0.15, xend = -0.15, y = 8.4, yend = 0.75, 
           colour = "#5e5e5e", size=3, alpha=1, arrow=arrow()) + 
  #arrow 2
  annotate("segment", x = -0.15, xend = -0.15, y = 8.6, yend = 17, 
           colour = "#5e5e5e", size=3, alpha=1, arrow=arrow()) + 
 
   #2 arrow labels
  annotate("text", x = c(-0.185,-0.185), y = c(4.8,12.5), 
          label = c("Lower activity in trisomy 12 CLL", 
                    "Higher activity in trisomy 12 CLL") , 
          color="black", 
          size=5 , fontface="bold") +
  #flip plot
  coord_flip() 

```

## Profiling the downstream effects of Spi-B and PU.1
Spi-B and PU.1 appeared to be upregulated in trisomy 12 CLL, and evidence in the literature indicated that these may regulate environmental sensing genes, providing a link between trisomy 12, and enhanced responses to external signals. 

To provide further evidence of this, I next aimed to profile the downstream effects of Spi-B and PU.1 in lymphoma. 

### Spi-B and PU.1 targets are enriched for immune signalling pathways
I hypothesised that Spi-B and PU.1 might coordinating transcriptional response to external signals, thus modulating CLL proliferation in response to the microenvironment. To identify Spi-B and PU.1 target genes specifically  in lymphoma, I acquired a ChIPseq dataset [@Care2014] containing data on Spi-B and PU.1 binding in lymphoma cell lines. I used this dataset to test for functional enrichment of immune signalling pathways amongst the TF targets. 

To define TF targets, I took the closest gene to each significant ChIP peak (q value<0.05), and within Â±1kb of TSS. I then tested for over-representation of these TF targets amongst selected KEGG[@KEGG] and Reactome [@Reactome] genesets, using the 'R' package `clusterProfiler` [@R-clusterProfiler]. This method corresponded to a one-sided version of Fisher's exact test. This analysis showed TLR, BCR and TGF$\beta$ signalling genes to be enriched (p<0.01) amongst Spi-B and PU.1 targets (Figure \@ref(fig:SpiBChipSeq).

(ref:SpiBChipSeq) Table shows results from over-representation tests of selected KEGG and Reactome pathways amongst Spi-B and PU.1 targets. Columns show geneset pathways, corresponding database, the number of genes within geneset, the number of Spi-B and PU.1 target genes within geneset (total number of target genes defined also shown), and p-value from over-representation test. TF targets defined as closest gene to each significant ChIP peak (q value<0.05), and within Â±1kb of TSS. ChIPseq data from @Care2014. Over-representation tests run using [@clusterProfiler] package, method corresponds to one-sided version of Fisherâ€™s exact test. Figure and caption from Bruch & Giles et al 2021. 
```{r SpiBChipSeq, fig.cap='(ref:SpiBChipSeq)', message = FALSE,  echo = FALSE, fig.height=2, fig.width = 15, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

#Get significant peaks
#filter ChipSeq data for peaks with significant score -log10(Qscore)>1.3
#if q < 0.05, then Qlog >1.3
spib.filtered <- peak.spib[(elementMetadata(peak.spib)[,1] > 1.3)]
pu1.filtered <- peak.pu1[(elementMetadata(peak.pu1)[,1] > 1.3)]


# Annotate peaks with meta data
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
peakAnno.spib <- annotatePeak(spib.filtered, 
                              tssRegion = c(-3000, 3000),
                              TxDb = txdb, 
                              annoDb = "org.Hs.eg.db")
peakAnno.pu1 <- annotatePeak(pu1.filtered, 
                             tssRegion = c(-3000, 3000),
                             TxDb = txdb, 
                             annoDb = "org.Hs.eg.db")
#Filter for genes within Â±1kb
peakAnno.spib.1kb <- as.data.frame(peakAnno.spib) %>% dplyr::filter(abs(distanceToTSS) <1000)
peakAnno.pu1.1kb <- as.data.frame(peakAnno.pu1) %>% dplyr::filter(abs(distanceToTSS) <1000)

#get  KEGG pathways from msigdbr database
kegg <- 
  msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG") %>% 
  #select pathway name and entrez id 
  dplyr::select(gs_name, entrez_gene)
#subset for pathways that we want to test
kegg <-
  dplyr::filter(kegg, 
         #All KEGG immune signaling pathways
         gs_name %in% c("KEGG_B_CELL_RECEPTOR_SIGNALING_PATHWAY",
                        "KEGG_CHEMOKINE_SIGNALING_PATHWAY",
                        "KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION", 
                        "KEGG_JAK_STAT_SIGNALING_PATHWAY" ,
                        "KEGG_NOD_LIKE_RECEPTOR_SIGNALING_PATHWAY"  , 
                        "KEGG_NOTCH_SIGNALING_PATHWAY", 
                        "KEGG_RIG_I_LIKE_RECEPTOR_SIGNALING_PATHWAY", 
                        "KEGG_TOLL_LIKE_RECEPTOR_SIGNALING_PATHWAY",
                        "KEGG_T_CELL_RECEPTOR_SIGNALING_PATHWAY",
                        #Control genesets
                        "KEGG_OXIDATIVE_PHOSPHORYLATION",                  
                        "KEGG_DNA_REPLICATION"
         ))
colnames(kegg) <- c("term", "gene")
#tidy up terms - remove KEGG, underscore and put in lower cases
kegg$term <- gsub("KEGG_", "",kegg$term )
kegg$term <- gsub("_", " ",kegg$term )
kegg$term <- gsub("B CELL RECEPTOR SIGNALING PATHWAY", 
                  "BCR Signaling Pathway",kegg$term )
kegg$term <- gsub("CHEMOKINE SIGNALING PATHWAY", 
                  "Chemokine Signaling Pathway",kegg$term )
kegg$term <- gsub("CYTOKINE CYTOKINE RECEPTOR INTERACTION", 
                  "Cytokine Cytokine Receptor Interaction",kegg$term )
kegg$term <- gsub("JAK STAT SIGNALING PATHWAY", 
                  "JAK STAT signaling pathway",kegg$term )
kegg$term <- gsub("NOD LIKE RECEPTOR SIGNALING PATHWAY", 
                  "NLR Signaling Pathway",kegg$term )
kegg$term <- gsub("NOTCH SIGNALING PATHWAY", 
                  "Notch Signaling Pathway",kegg$term )
kegg$term <- gsub("RIG I LIKE RECEPTOR SIGNALING PATHWAY", 
                  "RLR Signaling Pathway",kegg$term )
kegg$term <- gsub("TOLL LIKE RECEPTOR SIGNALING PATHWAY", 
                  "TLR Signaling Pathway",kegg$term )
kegg$term <- gsub("T CELL RECEPTOR SIGNALING PATHWAY", 
                  "TCR Signaling Pathway",kegg$term )
kegg$term <- gsub("OXIDATIVE PHOSPHORYLATION", 
                  "Oxidative Phosphorylation",kegg$term )
kegg$term <- gsub("P53 SIGNALING PATHWAY", 
                  "P53 Signaling Pathway",kegg$term )
kegg$term <- gsub("DNA REPLICATION", 
                  "DNA Replication",kegg$term )
kegg$genesetDatabase <- "KEGG"
#get reactome pathways
reactome <- 
  msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:REACTOME") %>% 
  #select pathway name and entrez id
  dplyr::select(gs_name, entrez_gene)
#subset for pathways that we want to test
reactome <-
  dplyr::filter(reactome, 
         gs_name %in% c(#selected immune pathways
                        "REACTOME_SIGNALING_BY_TGF_BETA_RECEPTOR_COMPLEX",
                        "REACTOME_TNF_SIGNALING",
                        "REACTOME_INTERLEUKIN_1_SIGNALING",
                        "REACTOME_INTERLEUKIN_10_SIGNALING",
                        "REACTOME_INTERLEUKIN_15_SIGNALING",
                        "REACTOME_INTERLEUKIN_2_SIGNALING",
                        "REACTOME_INTERLEUKIN_4_AND_INTERLEUKIN_13_SIGNALING",
                        "REACTOME_INTERLEUKIN_6_SIGNALING" ,
                        "REACTOME_OTHER_INTERLEUKIN_SIGNALING",
                        "REACTOME_SIGNALING_BY_INTERLEUKINS",
                        "REACTOME_INTERFERON_ALPHA_BETA_SIGNALING" ,
                        "REACTOME_INTERFERON_GAMMA_SIGNALING", 
                        #Control genesets
                        "REACTOME_CELL_CYCLE",                  
                        "REACTOME_REGULATION_OF_TP53_ACTIVITY" 
                        ))
colnames(reactome) <- c("term", "gene")
#tidy up terms
reactome$term <- gsub("REACTOME_", "",reactome$term )
reactome$term <- gsub("_", " ",reactome$term )
#tidy up and put in lower case
reactome$term <- gsub("CELL CYCLE", 
                      "Cell Cycle",reactome$term )
reactome$term <- gsub("INTERLEUKIN 1 SIGNALING", 
                      "Interleukin 1 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 10 SIGNALING", 
                      "Interleukin 10 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 15 SIGNALING", 
                      "Interleukin 15 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 2 SIGNALING", 
                      "Interleukin 2 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 4 AND INTERLEUKIN 13 SIGNALING", 
                      "Interleukin 4 and Interleukin 13 Signaling",reactome$term )
reactome$term <- gsub("INTERLEUKIN 6 SIGNALING",
                      "Interleukin 6 Signaling",reactome$term )
reactome$term <- gsub("OTHER INTERLEUKIN SIGNALING", 
                      "Other Interleukin Signaling",reactome$term )
reactome$term <- gsub("SIGNALING BY INTERLEUKINS", 
                      "Signaling by Interleukins",reactome$term )
reactome$term <- gsub("REGULATION OF TP53 ACTIVITY", 
                      "Regulation of TP53 Pathway",reactome$term )
reactome$term <- gsub("SIGNALING BY TGF BETA RECEPTOR COMPLEX",
                      "Signaling by TGFbeta \nReceptor Complex", reactome$term )
reactome$term <- gsub("TNF SIGNALING", 
                      "TNF Signaling",reactome$term )
reactome$term <- gsub("INTERFERON ALPHA BETA SIGNALING", 
                      "Interferon Alpha Beta Signaling",reactome$term )
reactome$term <- gsub("INTERFERON GAMMA SIGNALING", 
                      "Interferon Gamma Signaling", reactome$term )
#annotate which database these pathways come from 
reactome$genesetDatabase <- "Reactome"


#Run over-representation test forSPIB

#generate TERM2GENE dataframe to use in overrepresetation test
#join kegg and reactome gene sets together - this defines the list of pathways we are interested in, and select term and gene columns
term2gene <- rbind(kegg, reactome) %>% dplyr::select(term, gene)
#term2genesetdatabase - keep details of database source for each pathway 
term2genesetdatabase <- rbind(kegg, reactome) %>% dplyr::select(term, genesetDatabase)
colnames(term2genesetdatabase) <- c("term", "name")
##SPIB
#run over-representation test, and extract all results and p values:
#NB Bg ratio = number of genes in set / number of unique genes in term2gene, 
#NB Gene ratio = number of SPIB targets in gene set being tested / total number of SPIB targets that overlap with genes in term to gene
spibRes <- enricher(unique(as.data.frame(peakAnno.spib.1kb)$geneId), 
                    #Use pathways in term2gene
                    TERM2GENE=term2gene, 
                    #assign description for each term, as its database source
                    TERM2NAME = term2genesetdatabase, 
                    #no cutoffs on reported results, we want to see all results and p values 
                    minGSSize = 0,
                    maxGSSize = 1000,
                    pvalueCutoff = 1, 
                    qvalueCutoff = 1)
#get dataframe of results
spibRes.df <- fortify(spibRes, 
              showCategory = length(unique(term2gene$term)), #show all pathways tested
              split=NULL)
resTab.spib <-  
  mutate(spibRes.df, genesetSize = BgRatio*length(unique(term2gene$gene))) %>%  #multiply BgRatio by total genes tested to get number of genes in set
  dplyr::select(ID, Description, pvalue, Count, genesetSize)
colnames(resTab.spib) <- c("ID", "genesetDatabase", "pvalue_SPIB","count_SPIB", "genesetSize")


#Run over-representation test for PU1

##PU1
#run overepresentation test, and extract all results and pvalues (ie use p value and q value cutoff at 1) 
#NB not all results are shown because for some genesets there is no overlap between pu1 targets and geneset
pu1Res <- enricher(unique(as.data.frame(peakAnno.pu1.1kb)$geneId), 
                    TERM2GENE=term2gene, 
                    TERM2NAME = term2genesetdatabase, 
                    minGSSize = 0,
                    maxGSSize = 10000,
                    pvalueCutoff = 1, 
                    qvalueCutoff = 1)
#get dataframe of results
pu1Res.df <- fortify(pu1Res, 
              showCategory = length(unique(term2gene$term)), #show all pathways tested 
              split=NULL)
resTab.pu1 <-  mutate(pu1Res.df, genesetSize = BgRatio*length(unique(term2gene$gene))) %>%  #multiply BgRatio by total genes tested to get number of genes in set
  dplyr::select(ID, Description, pvalue, Count, genesetSize)
colnames(resTab.pu1) <- c("ID", "genesetDatabase", "pvalue_PU1","count_PU1", "genesetSize")


#join results for SPIB and PU1 together to show in one table
resTab <- full_join(resTab.spib, resTab.pu1)
#where count and p value is NA, put a 0 / 1 (ie there were no PU1/SPIB target genes in the set)
resTab$count_PU1[is.na(resTab$count_PU1)] <- 0
resTab$count_SPIB[is.na(resTab$count_SPIB)] <- 0
resTab$pvalue_SPIB[is.na(resTab$pvalue_SPIB)] <- 1
resTab$pvalue_PU1[is.na(resTab$pvalue_PU1)] <- 1
#select columns of interest to show in figure
resTab <- dplyr::select(resTab, ID, genesetDatabase, genesetSize,  count_SPIB, pvalue_SPIB,count_PU1, pvalue_PU1)
#adjust decimal places of p values
resTab$pvalue_SPIB <- round(resTab$pvalue_SPIB, digits = 3)
resTab$pvalue_PU1 <- round(resTab$pvalue_PU1, digits = 3)
#get significant results
resTab <- dplyr::filter(resTab, pvalue_SPIB<0.01|pvalue_PU1<0.01)
colnames(resTab) <- c("Pathway",
                      "Geneset Database" , 
                      "Geneset Size",  
                      #show the total number of SPIB targets in ChIPseq data 
                      paste("Spi-B targets (/" ,length(unique(as.data.frame(peakAnno.spib.1kb)$geneId)),")", sep= ""), 
                      "SPIB p-value", 
                      #show the total number of PU1 targets in ChIPseq data  
                      paste("PU.1 targets (/" ,length(unique(as.data.frame(peakAnno.pu1.1kb)$geneId)),")",sep= ""), 
                      "PU1 p-value")

ggtexttable(resTab, rows = NULL, 
           theme = ttheme(
             colnames.style = colnames_style(color = "white", fill = palreds[7], size = 16),
             tbody.style = tbody_style(color = "black",size = 18)
           )
)

```

### Visualisation of SPIB and PU1 binding sites from ChIPseq data in BCR, TLR, interleukin and TGFbeta signalling genes
Remove / Add if time
(Figure \@ref(fig:SpiBBindingSites).

(ref:SpiBBindingSites) 

```{r SpiBBindingSites, fig.cap='(ref:SpiBBindingSites)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

```

### Investigation of DE genes within IL4 and TGFbeta pathways in SPIB/PU1 DKO mice
Remove / Add if time
(Figure \@ref(fig:SpiBDEgenes).

(ref:SpiBDEgenes) 

```{r SpiBDEgenes, fig.cap='(ref:SpiBDEgenes)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

```

### Spi-B and PU.1 linked genes 
Key result: generation of GRN to identify SPIB and PU1 regulated genes, and investigation of associated log2FCs of these genes in trisomy 12 vs non-trisomy12 samples (including CD79A and B) 

Remove / Add if time 

(Figure \@ref(fig:SpiBGRN).

(ref:SpiBGRN) 

```{r SpiBGRN, fig.cap='(ref:SpiBGRN)', message = FALSE,  echo = FALSE, fig.height=5, fig.width = 5, fig.align="center", out.width = '60%', dev = 'cairo_pdf'}

```


### Double knockdown of Spi-B and PU.1 reduces profileration of trisomy 12+ cell lines
To establish the functional impact of Spi-B and PU.1 inihibiton in trisomy 12+ lymphoma, we tested th impact of inhibiting these TFs on profileration of lymphoma cell lines (Figure \@ref(fig:SpiBshRNAKD). We generated single and double shRNA knockdowns in lymphoma cell lines, namely SU-DHL4 and SU-DHL5 (trisomy 12+) and SU-DHL2 (no trisomy 12) and then measured cell counts at 24 hour intervals. 

(ref:SpiBshRNAKD) 

_The data here was generated by Tina Bericoviv and was included in Bruch & Giles et al. 2021. It is included in this thesis for completeness._ 

```{r SpiBshRNAKD, fig.cap='(ref:SpiBshRNAKD)', message = FALSE,  echo = FALSE, fig.height=3, fig.width = 7, fig.align="center", out.width = '100%', dev = 'cairo_pdf'}


  SPIB_KD_Cellcounts %>% 

  dplyr::filter(treatment%in%c("scr_shRNA", "PU.1-KD","SpiB-KD", "Double-KD")) %>% 
  mutate(treatment=factor(treatment, levels = c("scr_shRNA", "PU.1-KD", "SpiB-KD", "Double-KD"))) %>% 
  
  
  
  ggplot(aes(x=Day, y=NormalizedCellCount, color=treatment, group=interaction( treatment)))+
  stat_summary(fun = mean,geom='line',aes(color=treatment), size=1) +
  stat_summary(fun=mean,geom='point', size=2) +
  facet_wrap(~Cellline, scales="fixed")+
  scale_y_log10()+
  labs(y="Relative Cellcount")+
 t2+
  theme(legend.position = "bottom", legend.key = element_blank(), legend.title = element_text(face='bold', size=fontsize+4),  legend.text = element_text(size=fontsize+2), strip.background = element_blank(), strip.text = element_text(size=18, face="bold"))+
      scale_color_manual(name = "Condition", values = c("darkgrey", colors[c(7,8,3)]), labels=c("scr_shRNA"="Control","PU.1-KD"="PU.1-Knockdown","SpiB-KD"="Spi-B-Knockdown","Double-KD"="Spi-B + PU.1 Double Knockdown" ))


```

The single knockdowns had a small impact on proliferation: Spi-B inhibition reduced proliferation in SU-DHL5, as did  PU.1 to a lesser extent. Double knockdown of both TFs markedly reduced proliferation in SU-DHL2 and SU-DHL4, and was lethal in SU-DHL5. This result suggested that there is functional redundancy between Spi-B and PU.1 in this context, and that they are both important TFs in lymphoma.

Collectively, these results demonstrate trisomy 12 modulates responses to microenvironmental signals. We link trisomy 12 to higher Spi-B and PU.1 activity, and demonstrate that these TFs regulate genes relating to environmental sensing, and reduced profileration of cell lines when inhibited.

## Summary 
In this chapter, systematic survey of genetic determinants of microenvironmental response. Two key players emerge, that of TLR signalling, and that of trisomy 12  . We look at these in more detail, and in particular, investigate the mechanism by which trisomy 12 may module responses This analysis led to the identification of Spi-B and PU.1, which show higher activity in trisomy 12 and regulate environmental sensing genes. 

UP until now, cancer is understoof as a disease of genetics. We show it is importnat to understand this in context of signalling. 


## Discussion
REad up on trisomy 12
[@Abruzzo2018; @HerbstThesis; @MeierAbt2021, @JCI]. 

REad up on SPIb and PU1
SPib an dpU 1 regulate BTK: https://pubmed.ncbi.nlm.nih.gov/8934542/
SPIB and PU1 activity in B cells: https://pubmed.ncbi.nlm.nih.gov/15936902/
(hese data indicate that Spi-1 and Spi-B directly regulate the expression of Grap2 and that Grap2 functions to modulate BCR signaling, but that reduced Grap2 expression is unlikely to account for the BCR signaling defects observed in Spi1+/- SpiB-/- B cells.)
PU1 and SPIb and higher in Bc cells- this paper indicates this is to do with SP1 binding (which is on chromosome 12 and is hgiher ) https://pubmed.ncbi.nlm.nih.gov/7566969/
PU1 and PSIb bdinign in mouse lympohma cell ine https://pubmed.ncbi.nlm.nih.gov/25765478/
Spib and PU1 in B and T cell development https://pubmed.ncbi.nlm.nih.gov/8691135/

## Contributions

ATAC seq data set 
-planned by me and PEter, generated by PEter and Nayara

ATAC seq analysi s
-tri 12 annoation performed by ivan and me, diffTF analysi ran by Ivan, interpfreted by me 

TLR signalling: 
REad [@Chatzouli2017]
TLR stimulation can lead to both acitvation of MAPK and increase in viability or activation of apoptosis. If mutatiosn can affect which pathway is active, this poitns to aditoanl mechsnsim by which these mutations contribtue to CLL drive. It also points to TLR response as a useful prognostic marker.  

so everything is here 
focus on the content you have and finihsh - add additioanl if time 